{"version":3,"sources":["../src/viewer-props.ts","../src/event-source.ts","../src/gltf-layout.ts","../src/layout.ts","../src/create-gltf-layers.ts","../src/test.ts"],"sourcesContent":["import { OrbitViewState, DeckProps } from '@deck.gl/core/typed';\nimport {\n  Appearance,\n  DEFAULT_NAMESPACE,\n  Node,\n  NodeProps,\n} from '@paramountric/graph';\nimport { cubicIn } from './util/ease';\nimport { InteractionMode } from './interaction-manager';\n\nexport type SelectionStyle = {\n  fillColor?: [number, number, number, number];\n  strokeColor?: [number, number, number, number];\n  strokeWidth?: number;\n  filled?: boolean;\n  stroked?: boolean;\n};\n\nexport type NodeViewerProps = {\n  // try to clean this up\n  projectNode: NodeProps;\n  presenting?: boolean;\n\n  // OLD OPTIONS, MOVE UP OR DELETE\n\n  debug?: boolean;\n  insights?: Appearance[];\n  // many of the first properties are mandatory by logic (do not type it due to prototyping)\n  assetUrl?: string;\n  // urls\n  baseMapConfig?: {\n    [mapSetting: string]: string;\n  };\n  interactionMode?: InteractionMode;\n  onContextLost?: (event: any) => void;\n  // backend props\n  offline?: boolean; // if true, no backend fetching will be done\n  token?: string;\n  projectName?: string;\n  namespace?: string;\n  nodesUrl?: string;\n  hubUrl?: string;\n  speckleUrl?: string;\n  activeProjectIds?: { [projectId: string]: boolean };\n  typeNodes?: Node[];\n  propertyNodes?: Node[];\n  // initial layout\n  initialPortalLayout?: any;\n  // viewport size in pixels\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  // if this is used, no fetching from backend will be done\n  nodes?: Node[];\n  // camera\n  zoom?: number;\n  target?: [number, number, number];\n  rotationX?: number;\n  rotationOrbit?: number;\n  minZoom?: number;\n  maxZoom?: number;\n  // background\n  backgroundColor?: number[];\n  darkMode?: boolean;\n  darkModeBackgroundColor?: number[];\n  lightModeBackgroundColor?: number[];\n  // view\n  viewX?: number;\n  viewY?: number;\n  viewWidth?: number;\n  viewHeight?: number;\n\n  flyTo?: OrbitViewState;\n  flyToDuration?: number; // milliseconds\n  orthographic?: boolean;\n  disableController?: boolean;\n  disableController2?: boolean;\n  animate?: boolean;\n  animateNodes?: boolean; // for transitions on nodes\n  graph?: Node;\n\n  typeToAsset?: {\n    [type: string]: string; // string is full url to image/gltf (depending on file ending) on server\n  };\n\n  hideGrid?: boolean; // deactivate grid / points\n  hideViewportLayers?: boolean; // don't render viewport layers - for example if portal overlay\n  showNodeBorders?: boolean; // show helper borders around nodes - not to confuse with any node style\n\n  showTimeline?: boolean;\n  timelineStart?: Date; // start date\n  timelineEnd?: Date; // end date\n  timelineCursor?: Date; // cursor position\n  timelineSpeed?: number; // better make this slow/fast and then look at range to see how much time per step\n  timelineState?: 'play' | 'pause' | 'stop';\n\n  focusNode?: Node;\n  focusNodeWidth?: number;\n  focusNodeHeight?: number;\n\n  selectionStyle?: SelectionStyle;\n  resizeStyle?: SelectionStyle;\n\n  awsAccessKeyId?: string;\n  awsSecretAccessKey?: string;\n\n  presenters?: any;\n  // onClick?: (event: any) => void;\n  // layout?:\n  //   | 'force'\n  //   | 'tree'\n  //   | 'sankey'\n  //   | 'auto'\n  //   | 'manual'\n  //   | 'focus'\n  //   | undefined;\n  // these are the relations that will be shown on the canvas\n  relationKeys?: string[];\n  // this is the indicator key for the value that will be used from the nodes and edges\n  propertyKey?: string;\n  // actually we are using a list as well\n  propertyKeys?: string[];\n  // nodeGroups?: NodeGroups;\n  showCarrierNodesByType?: {\n    [type: string]: boolean;\n  };\n  edgeType?: 'straight' | 'bezier';\n  enableDragging?: boolean;\n  // gltfs?: GltfMap;\n  metadataLevels?: number;\n  autoGroupLimit?: number;\n  showTypeNodes?: boolean;\n\n  unlockOutgoingNodesOnDrag?: boolean;\n\n  lockNodesOnLayoutDone?: boolean;\n\n  stopForceLayoutAfterSeconds?: number;\n  showCircles?: boolean; // override squared only showing circles\n\n  // put all default node style into the nodeStyleProps\n  // nodeStyle?: NodeStyle;\n  // edgeStyle?: EdgeStyle;\n\n  showEdgeLabels?: boolean;\n\n  longitude?: number;\n  latitude?: number;\n  bearing?: number;\n  pitch?: number;\n  parent?: HTMLDivElement;\n  canvas?: HTMLCanvasElement | string;\n  meshData?: any;\n  mesh?: any;\n  meshes?: any; // map of { model (mesh data), modelMatrix}\n\n  useLightingEffects?: boolean;\n  postProcessEffects?: any; // an array of the configs of PostProcessEffect\n\n  onClick?: (info: any, e: any) => void;\n  transitions?: {\n    [propertyKey: string]: any;\n  };\n  disableTransitions?: boolean;\n  glOptions?: any;\n\n  ignoreDisconnectedNodes?: boolean;\n\n  // force\n  collisionRadius?: number;\n  alpha?: number;\n  resumeAlpha?: number;\n  nBodyStrength?: number;\n  nBodyDistanceMin?: number;\n  nBodyDistanceMax?: number;\n\n  // sankey\n  sankeyWidth?: number;\n  sankeyHeight?: number;\n  sankeyNodeWidth?: number;\n  sankeyNodePadding?: number;\n  sankeyHorizontalDistanceBetweenNodes?: number;\n  sankeyAutoSize?: boolean;\n  sankeyAlignment?: 'left' | 'right' | 'center' | 'justify';\n  useSankeyHeights?: boolean;\n\n  // these are for feeding in custom classes/settings for the json parser\n  classes?: any;\n  functions?: any;\n  enumerations?: any;\n  constants?: any;\n} & Omit<DeckProps, 'views'>;\n\n// this is overridden from board with the user settings on initial camera state\nexport const defaultState = {\n  id: 'master',\n  name: 'Board',\n  timing: 0,\n  slideDuration: 1000,\n  transitionDuration: 0,\n  transitionEasing: 'linear',\n};\n\nexport const defaultNodeViewerProps: NodeViewerProps = {\n  // this should be replaced from the data in DbBoard\n  projectNode: {\n    key: 'project',\n    name: { name: 'Project' },\n    type: 'Project',\n    namespace: DEFAULT_NAMESPACE,\n    appearance: defaultState, // the default insight of the board\n  },\n  insights: [], // the other slides\n};\n","export interface Event {\n  type: string;\n  data?: any;\n}\n\ntype Listener = (evt: Event) => any;\n\ntype ListenerRegistry = { [type: string]: Listener[] };\n\nfunction addEventListener(\n  type: string,\n  listener: Listener,\n  registry: ListenerRegistry\n) {\n  registry[type] = registry[type] || [];\n  if (registry[type].indexOf(listener) < 0) {\n    // Does not exist\n    registry[type].push(listener);\n  }\n}\n\nfunction removeEventListener(\n  type: string,\n  listener: Listener,\n  registry: ListenerRegistry\n) {\n  if (registry[type]) {\n    const index = registry[type].indexOf(listener);\n    if (index >= 0) {\n      registry[type].splice(index, 1);\n    }\n  }\n}\n\n/**\n * An event source can emit events and register event listeners\n */\nexport default class EventSource {\n  _listeners: ListenerRegistry = {};\n  _onceListeners: ListenerRegistry = {};\n\n  /**\n   * Adds a listener to a event type.\n   */\n  on(type: string, listener: Listener) {\n    addEventListener(type, listener, this._listeners);\n  }\n\n  /**\n   * Adds a listener that will be called only once to a event type.\n   */\n  once(type: string, listener: Listener) {\n    addEventListener(type, listener, this._onceListeners);\n  }\n\n  /**\n   * Removes a previously registered event listener.\n   */\n  off(type: string, listener: Listener) {\n    removeEventListener(type, listener, this._listeners);\n    removeEventListener(type, listener, this._onceListeners);\n  }\n\n  emit(eventOrType: string | Event, data?: any) {\n    let event: Event;\n    if (typeof eventOrType === 'string') {\n      event = { type: eventOrType };\n    } else {\n      event = eventOrType;\n    }\n\n    const type = event.type;\n\n    if (!this._listens(type)) {\n      return;\n    }\n\n    if (data) {\n      event.data = data;\n    }\n\n    // adding or removing listeners inside other listeners may cause an infinite loop\n    const listeners = this._listeners[type]?.slice() || [];\n\n    for (const listener of listeners) {\n      listener.call(this, event);\n    }\n\n    const onceListeners = this._onceListeners[type]?.slice() || [];\n    for (const listener of onceListeners) {\n      removeEventListener(type, listener, this._onceListeners);\n      listener.call(this, event);\n    }\n  }\n\n  /**\n   * Returns true if we have a listener for the event type.\n   */\n  private _listens(type: string): boolean {\n    return (\n      (this._listeners[type] && this._listeners[type].length > 0) ||\n      (this._onceListeners[type] && this._onceListeners[type].length > 0)\n    );\n  }\n}\n","import { Edge, Node, NodeProps, TYPE_FOREST } from '@paramountric/graph';\nimport { Layout, LayoutProps } from './layout';\nimport { lerp } from '@math.gl/core';\nimport { Deck, DeckProps, MapView, OrbitView } from '@deck.gl/core/typed';\nimport { createGltfLayers } from './create-gltf-layers';\n\nexport class GltfLayout extends Layout {\n  getView({\n    nodeProps,\n    interactionMode,\n    disableController,\n    orthographic,\n  }: {\n    nodeProps: NodeProps;\n    interactionMode: string;\n    disableController: boolean;\n    orthographic: boolean;\n  }): OrbitView | undefined {\n    const {\n      viewX,\n      viewY,\n      width,\n      height,\n      paddingLeft,\n      paddingBottom,\n      paddingRight,\n      paddingTop,\n    } = this.cameraFrame;\n\n    const uri = Node.nodePropsToUri(nodeProps);\n\n    return new OrbitView({\n      id: uri,\n      width: width,\n      height: height,\n      x: viewX,\n      y: viewY,\n      padding: {\n        left: paddingLeft || 0,\n        bottom: paddingBottom || 0,\n        right: paddingRight || 0,\n        top: paddingTop || 0,\n      },\n      controller: disableController\n        ? false\n        : {\n            // hack: just reverse the rotate to put it when panning (default)\n            dragMode: 'rotate',\n            dragPan: interactionMode === 'panning',\n            dragRotate: true,\n            inertia: false,\n            doubleClickZoom: false,\n            scrollZoom: disableController\n              ? null\n              : {\n                  speed: 0.01,\n                  smooth: true,\n                },\n          },\n      orthographic: false, // orthographic || false,\n      // near: 0.01,\n      // fovy: 30,\n      clear: true,\n      //  {\n      //   color: [0.5, 0.5, 0.5, 1],\n      //   depth: false,\n      //   stencil: false,\n      // },\n    } as any);\n  }\n\n  getLayers(interactionManager: any, parentNode: NodeProps, viewId: string) {\n    const { key, type, namespace, timing, appearance } = parentNode;\n    const gltfModelNode: NodeProps = {\n      key,\n      type,\n      namespace,\n      timing,\n      appearance: {\n        ...appearance,\n        position: [0, 0, 0],\n      },\n    };\n    const visibleNodes = [gltfModelNode];\n    const layers = [];\n    const gltfLayers = createGltfLayers({\n      visibleNodes,\n      layout: this,\n      interactionManager,\n      // parentNode,\n      viewId,\n    });\n    layers.push(...gltfLayers);\n    return layers;\n  }\n}\n","import {\n  Deck,\n  Layer,\n  MapView,\n  MapViewState,\n  OrbitView,\n  OrbitViewState,\n  OrbitViewport,\n  OrthographicView,\n  OrthographicViewState,\n} from '@deck.gl/core/typed';\nimport {\n  Edge,\n  EdgeMap,\n  Node,\n  //   // NodeMap,\n  //   NodeStyle,\n  RELATION_KEY_CONTAINED_IN,\n  RELATION_KEY_CONTAINS,\n  RELATION_KEY_DATA_SOURCE_TO,\n  RELATION_KEY_DOWNSTREAM,\n  RELATION_KEY_DOWNSTREAM_DEMAND,\n  RELATION_KEY_DOWNSTREAM_SUPPLY,\n  RELATION_KEY_HAS_DATA_SOURCE,\n  RELATION_KEY_HAS_PARENT,\n  RELATION_KEY_HAS_TYPE,\n  RELATION_KEY_TRACE,\n  RELATION_KEY_TRACK,\n  RELATION_KEY_UPSTREAM,\n  RELATION_KEY_UPSTREAM_DEMAND,\n  RELATION_KEY_UPSTREAM_SUPPLY,\n  EdgeProps,\n  NodeProps,\n  //   Appearance,\n  NodePropsMap,\n  NODE_TYPE_TYPE,\n  ParametricCube,\n  //   getCubesFromNodeProps,\n  getEdgeId,\n  //   NodeKeyframe,\n  //   mergeAppearance,\n  //   UpdateTriggers,\n} from '@paramountric/graph';\nimport { clamp, lerp } from '@math.gl/core';\n// import { Animation, Timeline } from '@paramountric/animation';\nimport {\n  DEFAULT_NODE_FILL_COLOR,\n  DEFAULT_NODE_SIZE,\n  DEFAULT_NODE_STROKE_COLOR,\n  NODE_DRAG_COLOR_FACTOR,\n  NODE_HOVER_COLOR_FACTOR,\n  NODE_INSIDE_COLOR_FACTOR,\n  NODE_MAX_SIZE,\n  NODE_MIN_SIZE,\n} from '@paramountric/layout';\n\n// import { lerp } from '../util/interpolators';\n// import { getPolygon } from '../util/polygon';\n// import { SELECTED_NODE_BOUNDS_KEY } from '../layers/create-node-selection-box-layer';\n// import { Animation, Timeline } from '@paramountric/animation';\n// import { appearanceDefaults, typeNodeDefaultsMap } from './appearance-defaults';\n\n// export type UpdateTriggers = {\n//   nodePositionChange?: number;\n//   nodeSizeChange?: number;\n//   nodeScaleChange?: number;\n//   nodeRotateChange?: number;\n//   nodeExtrusionChange?: number;\n//   nodeFillColorChange?: number;\n//   nodeStrokeColorChange?: number;\n//   nodeOpacityChange?: number;\n//   nodeLabelChange?: number;\n//   nodeIconChange?: number;\n//   mouseSelectionBoxChange?: number;\n//   selectedNodeBoundsChange?: number;\n//   resizeHandlesChange?: number;\n//   connectionHandlesChange?: number;\n//   edgeFillColorChange?: number;\n// };\n\n// todo: move this to central location, atm in interaction manager as well\nexport type PixelExtent = [number, number, number, number];\n\n// export type NodeInteractionState =\n//   | 'default'\n//   | 'hover'\n//   | 'dragging'\n//   | 'inside' // this will show the node to indicate it's temporarily inside another node (drag and drop - before drop)\n//   | 'outside' // like inside but the other way around\n//   | 'focus'; // one is focus node at a time, several can be selected\n\n// export type EdgeInteractionState = 'default' | 'hover' | 'focus'; // one is focus node at a time, several can be selected\n\nexport type LayoutProps = {\n  // needed for the viewId and used in layers to get the right match for layoutFilter\n  // however, the viewport can be sent into run function and in layers the interaction manager can reach the viewport\n  // parentNodeProps: NodeProps;\n  // send in children to init layout -> create animation timelines\n  // nodePropsList?: NodeProps[];\n  // edgePropsList?: EdgeProps[];\n  // need to send this in from the viewport instance so the timelines are in sync\n  // timeline: Timeline;\n  // if this layout has view\n  // cameraFrame?: Appearance;\n  // // needed for putting userData on the instance from the layout\n  // deck?: Deck;\n  // optional for additional settings from app, such as API keys (override constructor in specific layout)\n  // viewportProps?: ViewportProps;\n  // // for camera transitions (interpolate between viewStates)\n  // // ONE for each portal\n  // cameraAnimationProps?: AnimationProps;\n  // // for layer transitions (interpolate between layer state for example if all the nodes have the same setting, etc)\n  // // ONE for each layer (use layer id)\n  // layerAnimationProps?: AnimationProps[];\n  // // for node transitions (interpolate between node state - NodeStyle)\n  // // ONE for each node (use node id)\n  // nodeAnimationProps?: AnimationProps[];\n};\n\nexport abstract class Layout {\n  // use this to set the offset for children nodes\n  // (note that the nodeFrame of the parent layout must be called for the position using the versionUri)\n  // parentNodeProps: NodeProps;\n  id: string;\n\n  // as the BoardContext has the nodes - this reference is updated continuously on every change\n  nodes: NodePropsMap = new Map();\n\n  // this is for the user to interact with the camera - not part of animations\n  cameraFrame: any; // undefined | Appearance;\n\n  // animations: Map<string, Animation<Appearance>> = new Map();\n\n  // animationManager: AnimationManager;\n\n  // slideshow animations for camera, nodes, edges, layers\n  // cameraAnimation: Animation;\n  // layerAnimations: {\n  //   [layerId: string]: Animation;\n  // };\n  // nodeAnimations: {\n  //   [nodeUri: string]: Animation;\n  // };\n  // edgeAnimations: {\n  //   [edgeId: string]: Animation;\n  // };\n\n  // using observedAt unix epoch time\n  // cameraTimeline: Animation;\n  // layerTimelines: Animation;\n  // nodeTimelines: {\n  //   [nodeUri: string]: Animation;\n  // };\n  // edgeTimelines: {\n  //   [edgeId: string]: Animation;\n  // };\n\n  // unattachedAnimations = [];\n\n  // timeline is zero + any timing - null disables and insight animations\n  insightCursor: number | null = null;\n  // timeline: Timeline;\n\n  // set the types in the specific layout if applicable\n  // -> let the function in this class see if values can be used as default\n  // call default settings for nodes in frames on the fly\n  typeNodePropsMap: any = new Map(); // typeNodeDefaultsMap;\n\n  // cache polygons here instead of in the node\n  polygons: { [nodeUri: string]: number[][] } = {};\n\n  updateTriggers: any = {}; // UpdateTriggers = {};\n\n  // activate this by unlocki.ng the parent node - if not active use the picture of the viewport\n  _viewIsActive: boolean = false;\n\n  // _deck?: Deck;\n\n  constructor(\n    {\n      // parentNodeProps,\n      // nodePropsList = [],\n      // edgePropsList = [],\n      // // timeline,\n      // cameraFrame,\n      // deck,\n    }: LayoutProps\n  ) {\n    // this.parentNodeProps = parentNodeProps;\n    // this.id = Node.nodePropsToUri(parentNodeProps);\n    // this._deck = deck;\n    // todo: move animationManager to viewport and have one animation per view (boardLayout + nodeViewers)\n    // this.animationManager = new AnimationManager({\n    //   animations: [\n    //     // use animation.getKeyframes and animation.setKeyframes to add new node animations\n    //     new BBAnimation({\n    //       id: this.id,\n    //     }),\n    //   ],\n    // });\n    // this.layerAnimations = {};\n    // this.nodeAnimations = {};\n    // this.edgeAnimations = {};\n    // this.nodeTimelines = {};\n    // this.edgeTimelines = {};\n    // this.unattachedAnimations = [];\n    // this.timeline = timeline;\n    // if (cameraFrame) {\n    //   this.cameraFrame = cameraFrame;\n    // }\n    // console.log('init layout');\n    // if (parentNodeProps.appearance?.startWithActivatedView) {\n    //   this.setViewActive(true);\n    // }\n    // this.initNodeProps(nodePropsList, edgePropsList);\n  }\n\n  // // apply node appearances on animation keyframes\n  applyNodeProps(\n    allNodes: NodePropsMap,\n    changedNodeProps: NodeProps[],\n    cachedSegments?: ParametricCube[] // this is used by the cube layout / vega layouts\n  ) {\n    // always send in the latest state from context\n    this.nodes = allNodes;\n\n    for (const node of changedNodeProps) {\n      // if this is a type add it for default settings\n      if (node.type === NODE_TYPE_TYPE) {\n        this.typeNodePropsMap.set(node.key, node);\n      }\n    }\n\n    const changesWithRelations: NodeProps[] = [];\n\n    for (const node of changedNodeProps) {\n      const nodeUri = Node.nodePropsToUri(node);\n      node.nodeUri = nodeUri;\n\n      // if timing - add to animation\n      if (node.timing || node.timing === 0) {\n        // let animation = this.nodeAnimations[nodeUri];\n        // if (node.deletedAt) {\n        //   this.animations.delete(nodeUri);\n        // } else {\n        //   let animation = this.animations.get(nodeUri);\n        //   if (!animation) {\n        //     animation = new Animation<Appearance>({});\n        //     this.animations.set(nodeUri, animation);\n        //   }\n        //   animation.updateKeyframe(node, node.timing, this.timeline);\n        // }\n      } else {\n        // if no timing - the latest state should be in nodes using versionUri with 'latest'\n        // the update trigger in viewport should be used to assign update triggers and rerender\n      }\n      if (node.relations) {\n        changesWithRelations.push(node);\n      }\n    }\n\n    // apply any edges specified by node relations\n    for (const node of changesWithRelations) {\n      const { relations } = node;\n      const sourceUri = Node.nodePropsToUri(node);\n      for (const key of Object.keys(relations)) {\n        const targets = relations[key];\n        for (const target of targets) {\n          const edgeId = getEdgeId({\n            sourceUri,\n            relationKey: key,\n            targetUri: target,\n          } as EdgeProps);\n\n          // delete animation if node was deleted\n          // if (node.deletedAt) {\n          //   if (this.edgeAnimations[edgeId]) {\n          //     delete this.edgeAnimations[edgeId];\n          //   }\n          //   continue;\n          // }\n\n          // // add new animation if not exist\n          // if (!this.edgeAnimations[edgeId]) {\n          //   const edgeProps: EdgeProps = {\n          //     sourceUri,\n          //     targetUri: target,\n          //     relationKey: key,\n          //   };\n          //   // todo: like nodeProps -> get all with same id to construct the animation for all frames per edge id directlty\n          //   const edgeAnimationProps = getAnimationPropsFromEdgeId([edgeProps]);\n          //   this.edgeAnimations[edgeId] = new Animation(edgeAnimationProps);\n          // }\n        }\n      }\n    }\n  }\n\n  // // note that initial edge animations are done from the nodeProps relation, these props are additional settings for the edges saved separately\n  // applyEdgeProps(changedEdgeProps: EdgeProps[]) {\n  //   // for (const p of changedEdgeProps) {\n  //   //   const edgeId = this.createEdgeId(p.sourceUri, p.relationKey, p.targetUri);\n  //   //   this.visibleEdgePropsMap.set(edgeId, p);\n  //   // }\n  // }\n\n  // // nodeProps can be used to offset for parent node position\n  // // otherwise - if relative to parent is needed, first call run and after either:\n  // // 1. getLayers(parentNodeProps) or 2. autoLayout(parentNodeProps) <- the props has the correct position in style! (get from nodeFrame if needed)\n  // run(nodeProps?: NodeProps, viewport?: any) {}\n\n  // // just in case we need to have several views with same versionUri\n  // getViewId() {\n  //   return this.id;\n  // }\n\n  // // this matches from the above if using same layout, override to put in the parent view (for example boardLayout.id)\n  getLayerId(layerKey: string, viewId?: string) {\n    const viewIdToUse = viewId || this.id;\n    return `${viewIdToUse}-${layerKey}`;\n  }\n\n  // viewIsActive(isPresenting: boolean = false) {\n  //   // override if presenting as we want the view\n  //   if (isPresenting) {\n  //     return true;\n  //   }\n  //   return this._viewIsActive;\n  // }\n\n  // setViewActive(isActive: boolean) {\n  //   this._viewIsActive = isActive;\n  // }\n\n  // getView({\n  //   nodeProps,\n  //   interactionMode,\n  //   disableController,\n  //   orthographic,\n  // }: {\n  //   nodeProps: NodeProps;\n  //   interactionMode: string;\n  //   disableController: boolean;\n  //   orthographic: boolean;\n  // }): MapView | OrbitView | OrthographicView | undefined {\n  //   const {\n  //     viewX,\n  //     viewY,\n  //     width,\n  //     height,\n  //     paddingLeft,\n  //     paddingBottom,\n  //     paddingRight,\n  //     paddingTop,\n  //   } = this.cameraFrame;\n\n  //   const uri = Node.nodePropsToUri(nodeProps);\n\n  //   return new OrbitView({\n  //     id: uri,\n  //     width: width,\n  //     height: height,\n  //     x: viewX,\n  //     y: viewY,\n  //     padding: {\n  //       left: paddingLeft || 220,\n  //       bottom: paddingBottom || 0,\n  //       right: paddingRight || 220,\n  //       top: paddingTop || 0,\n  //     },\n  //     controller: disableController\n  //       ? false\n  //       : {\n  //           dragMode: interactionMode === 'rotating' ? 'rotate' : 'pan',\n  //           dragPan: interactionMode === 'panning',\n  //           dragRotate: interactionMode === 'rotating',\n  //           inertia: false,\n  //           doubleClickZoom: false,\n  //           scrollZoom: disableController\n  //             ? null\n  //             : {\n  //                 speed: 0.01,\n  //                 smooth: true,\n  //               },\n  //         },\n  //     orthographic: orthographic || false,\n  //     // near: 0.01,\n  //     // fovy: 30,\n  //     // clear: {\n  //     //   color: portal.frameState.backgroundColor || [99, 255, 255],\n  //     //   depth: true,\n  //     //   stencil: true,\n  //     // },\n  //   } as any);\n  // }\n\n  // getConnectionTypeFromRelationKey(edges: EdgeProps[]) {\n  //   return edges.reduce(\n  //     (acc, edge) => {\n  //       const { relationKey } = edge;\n  //       if (!relationKey) {\n  //         return acc;\n  //       }\n  //       switch (relationKey) {\n  //         // straight lines\n  //         case RELATION_KEY_HAS_TYPE:\n  //         case RELATION_KEY_CONTAINS:\n  //         case RELATION_KEY_CONTAINED_IN:\n  //         // case RELATION_KEY_HAS_INSIGHT:\n  //         // case RELATION_KEY_INSIGHT_FROM:\n  //         case RELATION_KEY_HAS_DATA_SOURCE:\n  //         case RELATION_KEY_DATA_SOURCE_TO:\n  //         case RELATION_KEY_TRACE:\n  //         case RELATION_KEY_TRACK:\n  //         case 'collaboratesOn':\n  //         case 'worksAt':\n  //         case 'isModelOf':\n  //         case 'isVersionOf':\n  //           acc.insight.push(edge);\n  //           break;\n  //         // bezier lines\n  //         case RELATION_KEY_DOWNSTREAM:\n  //         case RELATION_KEY_UPSTREAM:\n  //         case RELATION_KEY_UPSTREAM_SUPPLY:\n  //         case RELATION_KEY_UPSTREAM_DEMAND:\n  //         case RELATION_KEY_DOWNSTREAM_SUPPLY:\n  //         case RELATION_KEY_DOWNSTREAM_DEMAND:\n  //         case RELATION_KEY_HAS_PARENT:\n  //           acc.downstream.push(edge);\n  //           break;\n  //         default:\n  //           break;\n  //       }\n  //       return acc;\n  //     },\n  //     {\n  //       contains: [],\n  //       containedIn: [],\n  //       downstream: [],\n  //       upstream: [],\n  //       insight: [],\n  //     }\n  //   );\n  // }\n\n  // applyUpdateTriggers(updateTriggers: UpdateTriggers = {}) {\n  //   for (const triggerKey of Object.keys(updateTriggers)) {\n  //     if (updateTriggers[triggerKey]) {\n  //       this.updateTriggers[triggerKey] = Date.now();\n  //     }\n  //   }\n  // }\n\n  // // createPolygons() {\n  // //   const visibleNodes = this.getVisibleNodes();\n  // //   for (const node of visibleNodes) {\n  // //     const nodeUri = Node.nodePropsToUri(node);\n  // //     const frame = this.getNodeFrame(node);\n  // //     const size = frame.size;\n  // //     const position = frame.position;\n  // //     const minSize = Math.min(size[0], size[1]);\n  // //     const cornerRadius = clamp(\n  // //       minSize / 8,\n  // //       DEFAULT_NODE_SIZE / 8,\n  // //       DEFAULT_NODE_SIZE / 8\n  // //     );\n  // //     this.polygons[nodeUri] = getPolygon(\n  // //       [position[0], position[1]],\n  // //       size,\n  // //       cornerRadius\n  // //     );\n  // //   }\n  // // }\n\n  // // TIMELINE\n\n  // setInsightCursor(time: number | null) {\n  //   if (time === null) {\n  //     this.insightCursor = null;\n  //   } else {\n  //     const rounded = Math.round(time);\n  //     // this.timeline.setTime(rounded);\n  //     this.insightCursor = rounded;\n  //   }\n\n  //   // if (this.cameraAnimation) {\n  //   //   this.cameraAnimation.setTime(rounded);\n  //   // }\n  //   // for (const layerAnimation of Object.values(this.layerAnimations)) {\n  //   //   layerAnimation.setTime(rounded);\n  //   // }\n  //   // for (const nodeAnimation of Object.values(this.nodeAnimations)) {\n  //   //   nodeAnimation.setTime(rounded);\n  //   // }\n  //   // for (const edgeAnimation of Object.values(this.edgeAnimations)) {\n  //   //   edgeAnimation.setTime(rounded);\n  //   // }\n  // }\n\n  // // for unix time\n  // setTime(time: number) {\n  //   const rounded = Math.round(time);\n\n  //   // if (this.cameraTimeline) {\n  //   //   this.cameraTimeline.setTime(rounded);\n  //   // }\n  //   // for (const layerTimeline of Object.values(this.layerTimelines)) {\n  //   //   layerTimeline.setTime(rounded);\n  //   // }\n  //   // for (const nodeTimeline of Object.values(this.nodeTimelines)) {\n  //   //   nodeTimeline.setTime(rounded);\n  //   // }\n  //   // for (const edgeTimeline of Object.values(this.edgeTimelines)) {\n  //   //   edgeTimeline.setTime(rounded);\n  //   // }\n  // }\n\n  // // add the timeline to luma timeline and set the animationHandle\n  // // use this.setTimelines before running this\n  // // attachTimeline(lumaTimeline: Timeline) {\n  // //   for (const timeline of this.unattachedAnimations) {\n  // //     if (timeline.animationHandle) {\n  // //       lumaTimeline.detachAnimation(timeline.animationHandle);\n  // //     }\n  // //     timeline.animationHandle = lumaTimeline.attachAnimation(\n  // //       timeline,\n  // //       undefined // gets default time, no other channel seems to be used\n  // //     );\n  // //   }\n  // //   this.unattachedAnimations = [];\n  // // }\n\n  // // use this to set the keyframes, include timeline if not running attachTimeline afterwards with the luma timeline (like in portalManager constructor)\n  // // setAnimations({\n  // //   nodeAnimationProps = [],\n  // //   edgeAnimationProps = [],\n  // //   layerAnimationProps = [],\n  // //   cameraAnimationProps = undefined,\n  // //   lumaTimeline = undefined, // the portalManager.timeline should be used to sync between portals\n  // // }: {\n  // //   nodeAnimationProps?: AnimationProps[];\n  // //   edgeAnimationProps?: AnimationProps[];\n  // //   layerAnimationProps?: AnimationProps[];\n  // //   cameraAnimationProps?: AnimationProps;\n  // //   lumaTimeline?: Timeline;\n  // // }) {\n  // //   console.log('is setAminations called?? if not, how is timeline attached?');\n  // //   if (this.cameraAnimation && cameraAnimationProps) {\n  // //     this.cameraAnimation.setKeyFrameData(cameraAnimationProps);\n  // //   } else if (cameraAnimationProps) {\n  // //     this.cameraAnimation = new Animation(cameraAnimationProps);\n  // //     this.unattachedAnimations.push(this.cameraAnimation);\n  // //   }\n\n  // //   this.layerAnimations = layerAnimationProps.reduce((acc, timelineProps) => {\n  // //     if (acc[timelineProps.nodeUri]) {\n  // //       // if already exist - set the new keyframes (overrides the old ones)\n  // //       acc[timelineProps.nodeUri].setKeyFrameData(timelineProps);\n  // //     } else {\n  // //       // create new timeline\n  // //       acc[timelineProps.nodeUri] = new Animation(timelineProps);\n  // //       this.unattachedAnimations.push(acc[timelineProps.nodeUri]);\n  // //     }\n  // //     return acc;\n  // //   }, this.layerAnimations);\n\n  // //   this.nodeAnimations = nodeAnimationProps.reduce((acc, timelineProps) => {\n  // //     if (acc[timelineProps.nodeUri]) {\n  // //       // if already exist - set the new keyframes (overrides the old ones)\n  // //       acc[timelineProps.nodeUri].setKeyFrameData(timelineProps);\n  // //     } else {\n  // //       // create new timeline\n  // //       acc[timelineProps.nodeUri] = new Animation(timelineProps);\n  // //       this.unattachedAnimations.push(acc[timelineProps.nodeUri]);\n  // //     }\n  // //     return acc;\n  // //   }, this.nodeAnimations);\n\n  // //   // todo: check the typescript error\n  // //   // this.edgeAnimations = edgeAnimationProps.reduce((acc, timelineProps) => {\n  // //   //   if (acc[timelineProps.id]) {\n  // //   //     // if already exist - set the new keyframes (overrides the old ones)\n  // //   //     acc[timelineProps.id].setKeyFrameData(timelineProps);\n  // //   //   } else {\n  // //   //     // create new timeline\n  // //   //     acc[timelineProps.id] = new Animation<EdgeKeyframe>(timelineProps);\n  // //   //     this.unattachedAnimations.push(acc[timelineProps.id]);\n  // //   //   }\n  // //   //   return acc;\n  // //   // });\n\n  // //   // problem is that this function is called before portalManager is instantiated, in the constructor of portalManager to create the project portal\n  // //   const timeline = lumaTimeline;\n\n  // //   if (timeline) {\n  // //     this.attachTimeline(timeline);\n  // //   }\n  // // }\n\n  // // CAMERA\n\n  // hasView(): boolean {\n  //   return Boolean(this.cameraFrame);\n  // }\n\n  // // get viewState of interacting with camera\n  // getViewState() {\n  //   // only part of cameraFrame is viewState\n  //   return this.getCameraFrame(); // this.cameraAnimation.getFrameAt(0);\n  // }\n\n  // // set viewState of user interaction\n  // setCameraFrame(cameraFrame: Appearance) {\n  //   this.cameraFrame = {\n  //     ...this.cameraFrame,\n  //     ...cameraFrame,\n  //   };\n  // }\n\n  // // update the viewState from animation\n  // // the time is set first from viewport, how get the frame of the animation state and set to this.cameraFrame\n  // updateCameraFrameFromAnimation() {\n  //   // this.cameraFrame = this.cameraAnimation.getFrame();\n  // }\n\n  // // get viewState of user interaction, or if timing the camera animation\n  // getCameraFrame(): Appearance {\n  //   if (this.insightCursor !== null) {\n  //   }\n  //   return this.cameraFrame;\n  // }\n\n  // // get viewState of animation (the user interaction camera is this.cameraFrame)\n  // getCameraAnimationFrame(): Appearance {\n  //   // let cameraAnimation = this.cameraAnimation;\n  //   // // if the function is called inside of a child portal (node viewer) find the main portal timeline\n  //   // if (!cameraAnimation) {\n  //   //   return {};\n  //   // }\n  //   return {\n  //     // ...cameraAnimation.getFrame(),\n  //     // rotationX: Math.round(cameraAnimation.getFrame().rotationX),\n  //   };\n  // }\n\n  // createDefaultCameraTimelineProps(\n  //   attributes: string[],\n  //   attributeValues: any,\n  //   secondKeyframe?: Appearance\n  // ) {\n  //   return {\n  //     id: attributeValues.id,\n  //     attributes,\n  //     timings: [0, 1], // todo: build from slides! default master slide will have at least one duration\n  //     keyframes: [\n  //       {\n  //         ...attributeValues,\n  //       } as Appearance,\n  //       secondKeyframe ||\n  //         ({\n  //           ...attributeValues,\n  //         } as Appearance),\n  //     ],\n  //     easings: lerp,\n  //     interpolators: 'linear',\n  //   };\n  // }\n\n  // getBackgroundColor() {\n  //   // return undefined if not exist to continue looking for background color in the portal manager\n  //   return this.getCameraFrame()?.backgroundColor;\n  // }\n\n  // getZoom() {\n  //   return this.getCameraFrame()?.zoom || 0;\n  // }\n\n  // // getMinZoom() {\n  // //   return this.getCameraFrame().minZoom || DEFAULT_MIN_ZOOM;\n  // // }\n\n  // // getMaxZoom() {\n  // //   return this.getCameraFrame().maxZoom || DEFAULT_MAX_ZOOM;\n  // // }\n\n  // getRotationX() {\n  //   const cameraFrame = this.getCameraFrame();\n  //   return cameraFrame?.rotationX || 90;\n  // }\n\n  isTilted() {\n    // todo: check type of view, if map is going to need this function\n    // if (this.portal.activeRoomLayoutKey === 'map') {\n    //   return (this.getCameraFrame().pitch || 0) !== 0;\n    // }\n    return (this.cameraFrame?.rotationX || 0) !== 90;\n  }\n\n  // isRotated() {\n  //   return (this.cameraFrame?.rotationOrbit || 0) !== 0;\n  // }\n\n  // // NODE TIMELINE\n\n  // // get the node for the current time in the portalManager.timeline (it should be the _lastTime en each timeline instance) -> if not the frame will recalculate and set the cache\n  // getNodeFrame(nodeProps: NodeProps): Appearance | undefined {\n  //   if (!nodeProps.timing && nodeProps.timing !== 0) {\n  //     const versionUri = Node.nodePropsToVersionUri(nodeProps);\n  //     const node = this.nodes.get(versionUri);\n  //     if (node) {\n  //       return node.appearance;\n  //     } else {\n  //       // this happens for all default nodes (latest nodes without timing)\n  //       // console.warn('no node found in layout', this, versionUri);\n  //     }\n  //     // do not proceed\n  //     return undefined;\n  //   } else {\n  //     // const animation = this.animations.get(Node.nodePropsToUri(nodeProps));\n  //     // if (animation) {\n  //     //   const frame = animation.getFrame();\n  //     //   const reversedTimings = [...(animation.timings as [])].reverse();\n  //     //   frame.timing = reversedTimings.find(t => t <= this.insightCursor) || 0;\n  //     //   return frame;\n  //     // }\n  //     // return undefined;\n  //   }\n  // }\n\n  // getNodeFrameByUri(nodeUri: string): Appearance | undefined {\n  //   if (this.insightCursor === null) {\n  //     const latestNode = this.nodes.get(`${nodeUri}/latest`);\n  //     if (!latestNode) {\n  //       console.warn('no node found in layout nodes with /latest', nodeUri);\n  //       return undefined;\n  //     }\n  //     return this.getNodeFrame(latestNode);\n  //   } else {\n  //     return this.getNodeFrame(\n  //       Node.uriToNodeProps(nodeUri, { timing: this.insightCursor })\n  //     );\n  //   }\n  // }\n\n  // getNodeFrameAtTiming(\n  //   nodeProps: NodeProps,\n  //   timing: number\n  // ): Appearance | undefined {\n  //   const prevCursor = this.insightCursor;\n  //   this.setInsightCursor(timing);\n  //   const nodeFrame = this.getNodeFrame(nodeProps);\n  //   this.setInsightCursor(prevCursor);\n  //   return nodeFrame;\n  // }\n\n  // getResizeHandleRadius(interactionState: string) {\n  //   const connectionHandleRadius = 5;\n  //   const connectionHandleHoverRadius = 8;\n  //   if (interactionState === 'hover') {\n  //     return connectionHandleHoverRadius;\n  //   }\n  //   return connectionHandleRadius;\n  // }\n\n  // // Layer specific\n\n  // getTransitions() {\n  //   return undefined;\n  // }\n\n  // //\n\n  // will get nodes at the time position in timeline with correct appearance\n  getVisibleNodes(): NodeProps[] {\n    const currentTime = this.insightCursor;\n    const latestNodeProps = [...this.nodes.values()]\n      .filter(n => n.timing === undefined)\n      .map(n => {\n        n.versionUri = Node.nodePropsToVersionUri(n);\n        n.nodeUri = Node.nodePropsToUri(n);\n        return n;\n      });\n    if (currentTime === null) {\n      return latestNodeProps.filter(\n        n => n.appearance?.position && n.appearance?.size\n      );\n    }\n    // all nodes will have a latest node, used if no nodeFrame is found\n    // const timingNodeProps = latestNodeProps.map(latestNode => {\n    //   let nodeFrame = this.getNodeFrame({ ...latestNode, timing: currentTime });\n    //   if (!nodeFrame) {\n    //     // this is because some nodes only have zero timing - no animation can be done\n    //     nodeFrame = this.getNodeFrameAtTiming(latestNode, 0);\n    //   }\n    //   if (!nodeFrame) {\n    //     return latestNode;\n    //   }\n\n    //   // the most previous node is needed (get it from .timing)\n    //   // everything needed from latestNode should be merged at fetch from db\n    //   const timingNode =\n    //     this.nodes.get(`${latestNode.nodeUri}/${nodeFrame.timing}`) ||\n    //     latestNode;\n\n    //   return {\n    //     ...timingNode, // overall node data is here\n    //     appearance: mergeAppearance(timingNode.appearance, nodeFrame),\n    //     versionUri: Node.nodePropsToVersionUri({\n    //       ...timingNode,\n    //       timing: currentTime,\n    //     }),\n    //     timing: currentTime,\n    //   };\n    // });\n    // return timingNodeProps.filter(\n    //   n => n.appearance?.position && n.appearance?.size\n    // );\n  }\n\n  // getNodePropsFromNodeFrameUri(nodeUri: string): NodeProps {\n  //   const nodeFrame = this.getNodeFrameByUri(nodeUri);\n  //   const { key, namespace, type } = Node.uriToNodeProps(nodeUri);\n\n  //   if (!nodeFrame) {\n  //     return {\n  //       nodeUri,\n  //       key,\n  //       namespace,\n  //       type,\n  //       // name: '',\n  //       timing: this.insightCursor,\n  //       appearance: {},\n  //     };\n  //   }\n  //   return {\n  //     nodeUri,\n  //     key,\n  //     namespace,\n  //     type,\n  //     timing: this.insightCursor,\n  //     // name: nodeFrame.name,\n  //     appearance: nodeFrame,\n  //   };\n  // }\n\n  // getNodePosition(nodeProps: NodeProps, timing?: number) {\n  //   // const atTime = timing || this.timeline.getTime();\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   return frame?.position || [0, 0, 0];\n  // }\n\n  // // setNodePosition(nodeProps: NodeProps, position: [number, number, number]) {\n  // //   const nodeUri = Node.nodePropsToUri(nodeProps);\n  // //   const nodeTimeline = this.nodeTimelines[nodeUri];\n  // //   if (nodeTimeline) {\n  // //     nodeTimeline.setFrame({\n  // //       position,\n  // //     });\n  // //   }\n  // // }\n\n  // getNodeSize(nodeProps: NodeProps) {\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   return frame?.size || [0, 0];\n  // }\n\n  // getNodeRadius(nodeProps: NodeProps) {\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   if (frame) {\n  //     return frame.size[0] / 2 || 0;\n  //   }\n  //   return DEFAULT_NODE_SIZE;\n  // }\n\n  // getNodeExtrusion(nodeProps: NodeProps) {\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   return frame?.extrusion || 0;\n  // }\n\n  // getDefaultNodeSize(): number {\n  //   const zoom = this.getZoom();\n  //   return clamp(\n  //     DEFAULT_NODE_SIZE / 2 ** (zoom - 1),\n  //     NODE_MIN_SIZE,\n  //     NODE_MAX_SIZE\n  //   );\n  // }\n\n  // getNodeScale(nodeProps: NodeProps) {\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   return frame?.scale || [1, 1, 1];\n  // }\n\n  // getNodeOrientation(nodeProps: NodeProps) {\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   return frame?.rotation || [0, 0, 0];\n  // }\n\n  // // setNodeName(nodeUri: string, name: string) {\n  // //   const visibleNodeProps = this.nodeAnimations[nodeUri].getFrameAt(0);\n  // //   if (visibleNodeProps) {\n  // //     visibleNodeProps.name = name;\n  // //   }\n  // // }\n\n  // getNodeFillColor(\n  //   nodeProps: NodeProps,\n  //   interactionState?: string,\n  //   nodeType = 'default'\n  // ) {\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   const fallbackColor =\n  //     (this.typeNodePropsMap.get(nodeType)?.appearance?.fillColor as [\n  //       number,\n  //       number,\n  //       number,\n  //     ]) || DEFAULT_NODE_FILL_COLOR;\n\n  //   // console.log('fallbackColor', fallbackColor, nodeType);\n\n  //   if (!frame) {\n  //     return this.getColorNuanace([...fallbackColor, 255], interactionState);\n  //   }\n  //   const fillColor = frame.fillColor || fallbackColor;\n  //   const color = [...fillColor, frame.opacity || 1 * 255];\n  //   return this.getColorNuanace(\n  //     color as [number, number, number, number],\n  //     interactionState\n  //   );\n  // }\n\n  // getColorNuanace(\n  //   color: [number, number, number, number],\n  //   interactionState = 'default'\n  // ) {\n  //   if (interactionState === 'hover') {\n  //     color[0] = color[0] * NODE_HOVER_COLOR_FACTOR;\n  //     color[1] = color[1] * NODE_HOVER_COLOR_FACTOR;\n  //     color[2] = color[2] * NODE_HOVER_COLOR_FACTOR;\n  //   } else if (interactionState === 'dragging') {\n  //     color[0] = color[0] * NODE_DRAG_COLOR_FACTOR;\n  //     color[1] = color[1] * NODE_DRAG_COLOR_FACTOR;\n  //     color[2] = color[2] * NODE_DRAG_COLOR_FACTOR;\n  //   } else if (interactionState === 'inside') {\n  //     color[0] = color[0] * NODE_INSIDE_COLOR_FACTOR;\n  //     color[1] = color[1] * NODE_INSIDE_COLOR_FACTOR;\n  //     color[2] = color[2] * NODE_INSIDE_COLOR_FACTOR;\n  //   }\n  //   return color;\n  // }\n\n  // getNodeStrokeColor(nodeProps: NodeProps, interactionState?: string) {\n  //   const frame = this.getNodeFrame(nodeProps);\n  //   if (!frame) {\n  //     return this.getColorNuanace(\n  //       [...DEFAULT_NODE_STROKE_COLOR, 255],\n  //       interactionState\n  //     );\n  //   }\n  //   const strokeColor = frame.strokeColor || DEFAULT_NODE_STROKE_COLOR;\n  //   const color = [...strokeColor, frame.opacity || 1 * 255];\n  //   return this.getColorNuanace(\n  //     color as [number, number, number, number],\n  //     interactionState\n  //   );\n  // }\n\n  // getNodeImageUrl(props: NodeProps) {\n  //   const frame = this.getNodeFrame(props);\n  //   const fallbackImage =\n  //     this.typeNodePropsMap.get(props.type)?.appearance?.imageUrl ||\n  //     props.appearance?.imageUrl;\n  //   if (!frame) {\n  //     return fallbackImage;\n  //   }\n  //   const nodeImageUrl = frame.imageUrl || fallbackImage;\n  //   return nodeImageUrl;\n  // }\n\n  // getNodeAsset3dUrl(props: NodeProps) {\n  //   const frame = this.getNodeFrame(props);\n  //   const fallbackAsset =\n  //     this.typeNodePropsMap.get(props.type)?.appearance?.asset3dUrl ||\n  //     props.appearance?.asset3dUrl;\n  //   if (!frame) {\n  //     return fallbackAsset;\n  //   }\n\n  //   const nodeAsset3dUrl = frame.asset3dUrl || fallbackAsset;\n  //   return nodeAsset3dUrl;\n  // }\n\n  // getCornerRadius(type: 'node' | 'handle' = 'node'): number {\n  //   const zoom = this.getZoom();\n  //   const size = type === 'node' ? DEFAULT_NODE_SIZE * 4 : DEFAULT_NODE_SIZE;\n  //   return Math.min(DEFAULT_NODE_SIZE / 5, size / 2 ** zoom);\n  // }\n\n  // // updatePolygons(propsToUpdate?: NodeProps[]) {\n  // //   const visibleNodes = propsToUpdate || this.getVisibleNodes();\n  // //   const defaultNodeSize = this.getDefaultNodeSize();\n\n  // //   for (const nodeProps of visibleNodes) {\n  // //     const nodeUri = Node.nodePropsToUri(nodeProps);\n  // //     let size;\n  // //     let position;\n  // //     if (!nodeProps.timing && nodeProps.timing !== 0) {\n  // //       const versionUri = Node.nodePropsToVersionUri(nodeProps);\n  // //       const normalNode = this.nodes.get(versionUri);\n  // //       if (!normalNode) {\n  // //         console.log('no normal node found', versionUri);\n  // //         continue;\n  // //       }\n  // //       size = normalNode.appearance.size;\n  // //       position = normalNode.appearance.position;\n  // //     } else {\n  // //       const nodeFrame = this.getNodeFrame(nodeProps);\n  // //       if (!nodeFrame) {\n  // //         console.log('no node frame and timing found', nodeProps);\n  // //         continue;\n  // //       }\n  // //       size = nodeFrame.size;\n  // //       position = nodeFrame.position;\n  // //     }\n  // //     const minSize = Math.min(size[0], size[1]);\n  // //     const cornerRadius =\n  // //       nodeProps.layoutKey === 'map'\n  // //         ? 0\n  // //         : clamp(minSize / 8, defaultNodeSize / 16, defaultNodeSize / 8);\n  // //     this.polygons[nodeUri] = getPolygon(\n  // //       [position[0], position[1]],\n  // //       size,\n  // //       cornerRadius\n  // //     );\n  // //   }\n  // // }\n\n  // getExtrusionFactor() {\n  //   const zoom = this.getZoom();\n  //   return 5 / 2 ** zoom;\n  // }\n\n  // // get the node for the current time in the portalManager.timeline (it should be the _lastTime en each timeline instance) -> if not the frame will recalculate and set the cache\n  // getEdgeFrame(edge: EdgeProps): Appearance | undefined {\n  //   if (edge.timing === undefined) {\n  //     // const versionUri = Node.nodePropsToVersionUri(nodeProps);\n  //     // const node = this.nodes.get(versionUri);\n  //     // if (node) {\n  //     //   return node.appearance;\n  //     // }\n  //     // do not proceed\n  //     return undefined;\n  //   } else {\n  //     // const nodeKeyframes = this.getEdgeKeyframes(nodeProps);\n  //     // if (nodeKeyframes) {\n  //     //   return nodeKeyframes.getFrame();\n  //     // }\n  //     return undefined;\n  //   }\n  // }\n\n  // getEdgeFrameByEdgeId(edgeId: string): Appearance | undefined {\n  //   if (this.insightCursor === null) {\n  //     // const latestNode = this.nodes.get(`${nodeUri}/latest`);\n  //     // return this.getEdgeFrame(latestNode);\n  //     return undefined;\n  //   } else {\n  //     // return this.getEdgeFrame(\n  //     //   Node.uriToNodeProps(nodeUri, { timing: this.insightCursor })\n  //     // );\n  //     return undefined;\n  //   }\n  // }\n\n  // getVisibleEdges(): EdgeProps[] {\n  //   const currentTime = this.insightCursor;\n  //   const visibleNodes = this.getVisibleNodes();\n  //   const visibleNodeMap = visibleNodes.reduce(\n  //     (acc, props) => acc.set(props.nodeUri, props),\n  //     new Map<string, NodeProps>()\n  //   );\n\n  //   const visibleEdges = visibleNodes.reduce((acc, sourceNode) => {\n  //     const { relations = {} } = sourceNode;\n  //     const sourceUri = sourceNode.nodeUri;\n  //     for (const relationKey of Object.keys(relations)) {\n  //       const targets = relations[relationKey];\n  //       for (const targetUri of targets) {\n  //         // const targetVersionUri = `${targetUri}/${currentTime || currentTime === 0 ? currentTime : 'latest'}`;\n  //         const targetNode = visibleNodeMap.get(targetUri);\n  //         if (!targetNode) {\n  //           console.log('target node not visible', targetUri);\n  //           continue;\n  //         }\n  //         const edgeId = getEdgeId({\n  //           sourceUri,\n  //           relationKey,\n  //           targetUri,\n  //         } as EdgeProps);\n  //         // todo: figure out how to get frame, but also \"latest\" for edgeProps..\n  //         const edgeFrame = this.getEdgeFrameByEdgeId(edgeId) || {};\n  //         acc.push({\n  //           id: edgeId,\n  //           source: sourceNode,\n  //           target: targetNode,\n  //           sourceUri,\n  //           targetUri,\n  //           relationKey,\n  //           appearance: edgeFrame,\n  //           timing: currentTime,\n  //         });\n  //       }\n  //     }\n  //     return acc;\n  //   }, [] as EdgeProps[]);\n\n  //   return visibleEdges;\n\n  //   // const edges = Object.keys(this.edgeAnimations).reduce(\n  //   //   (acc: EdgeProps[], edgeId: string) => {\n  //   //     const animation = this.edgeAnimations[edgeId];\n  //   //     const edgeFrame = animation.getFrame();\n  //   //     const { sourceUri, targetUri, relationKey } = animation;\n  //   //     const sourceNode = visibleNodeMap.get(sourceUri);\n  //   //     const targetNode = visibleNodeMap.get(targetUri);\n  //   //     if (!sourceNode || !targetNode) {\n  //   //       console.log('source or target node not found', sourceUri, targetUri);\n  //   //       return acc;\n  //   //     }\n  //   //     const edgeProps: EdgeProps = {\n  //   //       edgeId: getEdgeId({\n  //   //         sourceUri,\n  //   //         relationKey,\n  //   //         targetUri,\n  //   //       }),\n  //   //       sourceUri,\n  //   //       targetUri,\n  //   //       relationKey,\n  //   //       appearance: edgeFrame,\n  //   //     };\n  //   //     acc.push(edgeProps);\n  //   //     return acc;\n  //   //   },\n  //   //   [] as EdgeProps[]\n  //   // );\n  //   // return edges;\n  //   // return [];\n  // }\n\n  // getEdgeFillColor(edgeProps: EdgeProps, interactionState?: string) {\n  //   const fillColor = edgeProps.appearance?.fillColor || [160, 160, 160, 200];\n  //   return this.getColorNuanace(\n  //     fillColor as [number, number, number, number],\n  //     interactionState\n  //   );\n  // }\n\n  // getEdgeWidth(edge: any) {\n  //   // const interactionState =\n  //   //   this.interactionManager.edgeInteractionStates[edge.id] || 'default';\n  //   // const isSelected = this.interactionManager.selectedEdges[edge.id];\n  //   // if (interactionState === 'hover' || isSelected) {\n  //   //   return 3;\n  //   // }\n  //   return 3;\n  // }\n\n  // // uses a polygon with the id SELECTED_NODE_BOUNDS_KEY and triggers the selection-bounds-layers\n  // updateSelectedNodesBox(versionUris: string[]): PixelExtent | undefined {\n  //   if (!versionUris.length) {\n  //     // delete this.polygons[SELECTED_NODE_BOUNDS_KEY];\n  //     this.updateTriggers.selectedNodeBoundsChange = Date.now();\n  //     return;\n  //   }\n  //   const min = [Number.MAX_VALUE, Number.MAX_VALUE];\n  //   const max = [Number.MIN_VALUE, Number.MIN_VALUE];\n  //   // console.log('versionUris', versionUris);\n  //   for (const versionUri of versionUris) {\n  //     const nodeUri = Node.versionUriToNodeUri(versionUri);\n  //     const nodeFrame = this.getNodeFrameByUri(nodeUri);\n  //     if (!nodeFrame) {\n  //       console.log('no node frame for selection box', nodeUri);\n  //       continue;\n  //     }\n  //     const size = nodeFrame.size;\n  //     const position = nodeFrame.position;\n  //     const x = position[0] - size[0] / 2;\n  //     const y = position[1] - size[1] / 2;\n  //     min[0] = Math.min(min[0], x);\n  //     min[1] = Math.min(min[1], y);\n  //     max[0] = Math.max(max[0], x + size[0]);\n  //     max[1] = Math.max(max[1], y + size[1]);\n  //   }\n  //   const defaultNodeSize = this.getDefaultNodeSize();\n  //   const minSize = Math.min(max[0] - min[0], max[1] - min[1]);\n  //   const cornerRadius = clamp(\n  //     minSize / 8,\n  //     defaultNodeSize / 16,\n  //     defaultNodeSize / 8\n  //   );\n  //   const padding = cornerRadius / 2;\n  //   const width = max[0] - min[0] + padding * 2;\n  //   const height = max[1] - min[1] + padding * 2;\n  //   // this.polygons[SELECTED_NODE_BOUNDS_KEY] = getPolygon(\n  //   //   [(min[0] + max[0]) / 2, (min[1] + max[1]) / 2],\n  //   //   [width, height],\n  //   //   cornerRadius\n  //   // );\n  //   this.updateTriggers.selectedNodeBoundsChange = Date.now();\n  //   return [min[0], min[1], max[0], max[1]] as PixelExtent;\n  // }\n\n  // // TRIGGERS\n\n  // setLastNodePositionUpdate() {\n  //   this.updateTriggers.nodePositionChange = Date.now();\n  // }\n\n  // setLastNodeStyleUpdate() {\n  //   this.updateTriggers.nodeFillColorChange = Date.now();\n  //   this.updateTriggers.nodeStrokeColorChange = Date.now();\n  // }\n\n  //\n  getLayerFrame(layerId: string) {\n    // const layerKeyframes = this.animations.get(layerId);\n    // if (layerKeyframes) {\n    //   console.log('layerKeyframes', layerKeyframes);\n    //   return layerKeyframes.getFrame();\n    // }\n  }\n\n  getLayerFillColor(layerId: string) {\n    const frame = this.getLayerFrame(layerId);\n    // if (frame?.fillColor) {\n    //   return frame.fillColor;\n    // }\n    // if (\n    //   !appearanceDefaults[layerId] ||\n    //   !appearanceDefaults[layerId].fillColor\n    // ) {\n    //   console.warn(\n    //     'no fill color for layer - return blue -> fix a color',\n    //     layerId\n    //   );\n    // }\n    // return appearanceDefaults[layerId]?.fillColor || [0, 0, 255];\n  }\n}\n","import { PickingInfo, Color } from '@deck.gl/core/typed';\nimport {\n  ScenegraphLayer,\n  ScenegraphLayerProps,\n} from '@deck.gl/mesh-layers/typed';\nimport { NodeProps } from '@paramountric/graph';\nimport { Layout } from './layout';\n\ninterface INodeLayer {\n  visibleNodes: NodeProps[];\n  layout: Layout;\n  interactionManager: any;\n  parentNode?: NodeProps;\n  viewId: string; // this is because the layout and viewId is not the same in some layouts - the geo-layout for example are viewed inside board-layout but has it's own layout id\n}\n\nexport function createGltfLayers({\n  visibleNodes,\n  layout,\n  interactionManager,\n  parentNode,\n  viewId,\n}: INodeLayer): ScenegraphLayer[] {\n  const nodesWithGltf = visibleNodes.filter(\n    (props: NodeProps) =>\n      props.appearance?.asset3dUrl ||\n      layout.typeNodePropsMap.get(props.type)?.appearance?.asset3dUrl\n  );\n\n  const updateTriggers = {\n    getPosition: layout.updateTriggers.nodePositionChange,\n    getScale: layout.updateTriggers.nodeScaleChange,\n    getOrientation: layout.updateTriggers.nodeRotateChange,\n  };\n\n  // this is optional, the position is sometimes already correct and sometimes it needs this (node viewers for example)\n  const parentX = parentNode?.appearance?.position![0] || 0;\n  const parentY = parentNode?.appearance?.position![1] || 0;\n\n  const extrusionFactor = 1; // layout.getExtrusionFactor();\n\n  const scenegraphPropsMap = new Map<string, ScenegraphLayerProps<NodeProps>>();\n  nodesWithGltf.forEach((n: NodeProps) => {\n    const asset3dUrl =\n      n.appearance?.asset3dUrl ||\n      layout.typeNodePropsMap.get(n.type)?.appearance?.asset3dUrl;\n    if (asset3dUrl && !scenegraphPropsMap.has(asset3dUrl)) {\n      scenegraphPropsMap.set(asset3dUrl, {\n        id: layout.getLayerId(asset3dUrl, viewId),\n        data: [] as NodeProps[],\n        // material: false,\n        // texture: null,\n        // visible: true, // layout.isTilted(),\n        _animations: {\n          '*': { speed: 1 },\n        },\n        _lighting: 'pbr',\n        pickable: true,\n        scenegraph: asset3dUrl,\n        sizeScale: 1,\n        getPosition: (n: NodeProps) => {\n          const { position, extrusion = 1 } = n.appearance || {};\n          const elevation = extrusion;\n          const z = elevation * extrusionFactor;\n          const pos = position || [0, 0];\n          return [pos[0] + parentX, pos[1] + parentY, z + 8];\n        },\n        getScale: (n: NodeProps) => {\n          const scale = n.appearance?.scale || [1, 1, 1];\n          return [scale[0] * 4, scale[1] * 4, scale[2] * 4];\n        },\n        // Object orientation defined as a vec3 of Euler angles, [pitch, yaw, roll] in degrees. This will be composed with layer's modelMatrix.\n        getOrientation: (n: NodeProps) => {\n          return layout.isTilted() ? [0, 0, 90] : [-45, 0, 0];\n          // return layout.getNodeOrientation(n.versionUri);\n        },\n        updateTriggers,\n      });\n    }\n    const scenegraphProps = scenegraphPropsMap.get(asset3dUrl || '');\n    // @ts-ignore\n    scenegraphProps.data.push(n);\n  });\n\n  return [...scenegraphPropsMap.values()].map(scenegraphProps => {\n    return new ScenegraphLayer(scenegraphProps);\n  });\n}\n","import {\n  Deck,\n  DeckProps,\n  FilterContext,\n  Layer,\n  MapView,\n  MapViewState,\n  OrbitView,\n  OrbitViewState,\n  OrthographicView,\n  OrthographicViewState,\n} from '@deck.gl/core/typed';\nimport GL from '@luma.gl/constants';\nimport {\n  NODE_TYPE_PROJECT,\n  SyntheticNode,\n  Node,\n  NODE_TYPE_BUCKET,\n  getNodePropsFromParametricInputParamsList,\n  getCubesFromNodeProps,\n  ParametricCube,\n  NodeKeyframe,\n  RELATION_KEY_HAS_DATA_SOURCE,\n  getDataSourceNodeProps,\n  NodeProps,\n  EdgeProps,\n  Appearance,\n  getChildNodes,\n  NodePropsMap,\n  getEdgeId,\n  mergeNodeProps,\n  UpdateTriggers,\n  getSegmentsFromNodeProps,\n} from '@paramountric/graph';\n// import { Portal, PortalProps } from './portal';\nimport { convertArrayOfObjectsToCSV } from './util/objectToCsv';\nimport { NodeViewerProps, defaultNodeViewerProps } from './viewer-props';\nimport EventSource from './event-source';\nimport { getIconAtlas } from './layers/arrows';\nimport { lerp } from './util/interpolators';\nimport { ViewStateChangeParameters } from '@deck.gl/core/typed/controllers/controller';\n// import { Interaction } from './interaction/interaction';\n// import ZoomToNodeInterpolator from './zoom-to-node-interpolator';\n// import { ManualLayout } from './layouts/manual-layout';\n// import { EdgeInteractionState, NodeInteractionState } from './layouts/layout';\nimport {\n  // BEZIER_EDGE_LABEL_LAYER_ID,\n  ChartLayout,\n  DEFAULT_BACKGROUND_COLOR,\n  DEFAULT_MAX_ZOOM,\n  DEFAULT_MIN_ZOOM,\n  // DEFAULT_START_ZOOM,\n  // DEFAULT_VIEW_AREA_SIZE,\n  // EDGE_NODE_LAYER_KEY,\n  // BoardLayout,\n  // MapLayout,\n  // GeoLayout,\n  // GltfLayout,\n  // ImageLayout,\n  // Layout,\n  // LayoutProps,\n  // NODE_POLYGON_LAYER_KEY,\n  // STRAIGHT_EDGE_LABEL_LAYER_ID,\n  // TILE_SIZE,\n  // SupplyChainLayout,\n  // getSupplyChainLayout,\n  // VegaLayout,\n} from '@paramountric/layout';\nimport {\n  EdgeInteractionState,\n  InteractionManager,\n  InteractionMode,\n  NodeInteractionState,\n  Pixel,\n} from './interaction-manager';\nimport { debounce } from './util/debounce';\nimport { Timeline } from '@paramountric/animation';\nimport { GltfLayout } from './gltf-layout';\n\nconst DEBUG = true;\n\n// this has keys from both RoomLayoutKey and BucketLayoutKey!!\nconst availableLayouts = {\n  // manual: BoardLayout,\n  // cubes: ChartLayout,\n  // // vega: ChartLayout,\n  // image: ImageLayout,\n  // // force: ForceLayout,\n  // // cubes: CubesLayout,\n  // // sankey: SankeyLayout,\n  // // supplychain: SupplyChainLayout,\n  gltf: GltfLayout,\n};\n\nexport class NodeViewer extends EventSource {\n  props: NodeViewerProps;\n  deck: Deck | null;\n  canvas: HTMLCanvasElement;\n  // boardLayout: BoardLayout;\n  nodeViewLayouts: {\n    [nodeUri: string]: any;\n  } = {}; //Map<string, Layout> = new Map();\n\n  // keep the cache ref here so that nodes can be found from viewport by versionUri\n  nodes: NodePropsMap = new Map();\n\n  projectNode: NodeProps;\n  // we want to sync each portal keyframes, so the timeline is shared\n  timeline: Timeline;\n  interactionManager: InteractionManager;\n  interactionMode: InteractionMode = 'panning';\n  shouldAnimate: boolean = false;\n  videoCapture: any; // todo: check out capture/video-capture\n  presenting: boolean = false;\n\n  // versionUri cache for parametric cubes\n  cubeCache: Map<string, ParametricCube[]> = new Map();\n\n  // only use to rerender selection bounds\n  selectedVersionUriCache: string[] = [];\n\n  blob: Blob;\n  mimeType: string = 'image/png';\n  quality: number = 1;\n\n  constructor(viewportProps: NodeViewerProps) {\n    super();\n\n    const { interactionMode, debug, projectNode, presenting, ...restProps } =\n      viewportProps;\n    const { projectNode: defaultProjectNode, ...restDefaultNodeViewerProps } =\n      defaultNodeViewerProps;\n    const resolvedProps = Object.assign(\n      {\n        // default - will be overwritten by restProps\n        width: window.innerWidth,\n        height: window.innerHeight,\n      },\n      restDefaultNodeViewerProps,\n      restProps,\n      // will overwrite default and sent in\n      {\n        // onLoad: this.onLoad.bind(this),\n        onError: (error: Error) => {\n          if (viewportProps.onContextLost) {\n            viewportProps.onContextLost(error);\n          }\n        },\n        // onHover: this.onHover.bind(this),\n        // onResize: this.onResize.bind(this),\n        // getCursor: this.interactionManager.getCursor,\n        getTooltip: null,\n        // id: 'viewport',\n        debug: DEBUG || debug || false,\n      }\n    ) as DeckProps;\n    // this.props = resolvedProps as NodeViewerProps;\n    // this.presenting = presenting || false;\n\n    // if (interactionMode) {\n    //   this.interactionMode = interactionMode;\n    // }\n\n    // this.timeline = new Timeline();\n\n    // const position = (\n    //   projectNode.appearance?.position\n    //     ? [...projectNode.appearance.position]\n    //     : [TILE_SIZE / 2, TILE_SIZE / 2, 0]\n    // ) as [number, number, number];\n\n    // const initialCameraFrame: Appearance = {\n    //   position: position,\n    //   target: position,\n    //   zoom: projectNode.appearance?.zoom || DEFAULT_START_ZOOM,\n    //   rotationOrbit: projectNode.appearance?.rotationOrbit || 0,\n    //   rotationX: projectNode.appearance?.rotationX || 90,\n    //   minZoom: projectNode.appearance?.minZoom || DEFAULT_MIN_ZOOM,\n    //   maxZoom: projectNode.appearance?.maxZoom || DEFAULT_MAX_ZOOM,\n    //   backgroundColor:\n    //     projectNode.appearance?.backgroundColor ||\n    //     (DEFAULT_BACKGROUND_COLOR as [number, number, number]),\n    //   viewX: projectNode.appearance?.viewX || 0,\n    //   viewY: projectNode.appearance?.viewY || 0,\n    //   paddingLeft: projectNode.appearance?.paddingLeft || 0,\n    //   // width: this.props.width,\n    //   // height: this.props.height,\n    // };\n\n    // this.projectNode = {\n    //   id: projectNode.id || defaultProjectNode.id,\n    //   key: projectNode.key || defaultProjectNode.key,\n    //   type: NODE_TYPE_PROJECT,\n    //   name: projectNode.name || defaultProjectNode.name,\n    //   // the projectNode is the board and the id === boardId\n    //   boardId: projectNode.id || defaultProjectNode.id,\n    //   namespace: projectNode.namespace || defaultProjectNode.namespace,\n    //   appearance: {\n    //     // add settings from DB for the board / node here\n    //     ...initialCameraFrame,\n    //     // cannot override the size of the board\n    //     size: [DEFAULT_VIEW_AREA_SIZE, DEFAULT_VIEW_AREA_SIZE],\n    //   },\n    // };\n    // this.boardLayout = new BoardLayout({\n    //   parentNodeProps: this.projectNode,\n    //   nodePropsList: [],\n    //   edgePropsList: [],\n    //   timeline: this.timeline,\n    //   cameraFrame: {\n    //     ...initialCameraFrame,\n    //   },\n    // });\n    // console.log('this.boardLayout', this.boardLayout);\n    // console.log('id', this.boardLayout.getViewId());\n    // this.interactionManager = new InteractionManager({ viewport: this });\n\n    // console.log(this.projectNode, '<- p');\n\n    // // this.onViewStateChange = this.onViewStateChange.bind(this);\n    // // this.layerFilter = this.layerFilter.bind(this);\n\n    // console.log('viewport', resolvedProps);\n    // this.deck = new Deck(resolvedProps);\n    // console.log('deck', this.deck);\n  }\n\n  // // call from a react component on unmount\n  // dispose() {\n  //   this.deck?.finalize();\n  //   this.deck = null;\n  // }\n\n  // onLoad() {\n  //   console.log('onLoad');\n  //   // @ts-ignore\n  //   const { gl } = this.deck.deckRenderer;\n  //   this.deck._addResources({\n  //     arrowAtlas: getIconAtlas(gl),\n  //   });\n  //   // @ts-ignore\n  //   this.canvas = this.deck.canvas;\n\n  //   // this.canvas.addEventListener(\n  //   //   'mousemove',\n  //   //   this.interactionManager.onMouseMove\n  //   // );\n  //   // this.canvas.addEventListener(\n  //   //   'mousedown',\n  //   //   this.interactionManager.onMouseDown\n  //   // );\n  //   // this.canvas.addEventListener('mouseup', this.interactionManager.onMouseUp);\n  //   // this.canvas.addEventListener(\n  //   //   'mouseout',\n  //   //   this.interactionManager.onMouseOut\n  //   // );\n  //   // // add event listener for scroll wheel\n  //   // this.canvas.addEventListener('wheel', this.interactionManager.onWheel);\n  //   // this.canvas.addEventListener('dragover', e => {\n  //   //   e.preventDefault();\n  //   // });\n  //   // this.canvas.addEventListener('drop', (e: any) => {\n  //   //   e.preventDefault();\n  //   //   if (e.dataTransfer?.files?.length > 0) {\n  //   //     this.fileManager.importFile(\n  //   //       e.dataTransfer.files[0],\n  //   //       e.clientX,\n  //   //       e.clientY\n  //   //     );\n  //   //   }\n  //   // });\n\n  //   this.update();\n  //   this.emit('viewport:onload');\n  // }\n\n  // boardIsTilted() {\n  //   return this.boardLayout.isTilted();\n  // }\n\n  // getBoardZoom() {\n  //   return this.boardLayout.getZoom();\n  // }\n\n  // getViews() {\n  //   const views = [\n  //     this.boardLayout.getView({\n  //       nodeProps: this.boardLayout.parentNodeProps,\n  //       interactionMode: this.interactionMode,\n  //       disableController: this.interactionManager.disableController,\n  //       orthographic: this.props.orthographic === false ? false : true,\n  //     }),\n  //   ];\n\n  //   // todo: should render a picture on the parent node until the user interacts with the view\n  //   // also, in 3D the view cannot be shown -> should have a 3D representation of all views (optimised)\n  //   if (!this.boardLayout.isTilted() && !this.boardLayout.isRotated()) {\n  //     const children = this.boardLayout.getVisibleNodes() || [];\n  //     for (const child of children) {\n  //       const nodeUri = child.nodeUri;\n  //       const layout = this.nodeViewLayouts[nodeUri];\n  //       if (\n  //         layout &&\n  //         layout.hasView() &&\n  //         layout.viewIsActive(this.presenting)\n  //       ) {\n  //         const view = this.nodeViewLayouts[nodeUri]?.getView({\n  //           nodeProps: child,\n  //           orthographic: child.appearance?.orthographic || false,\n  //           disableController: this.presenting,\n  //         });\n  //         views.push(view);\n  //       }\n  //     }\n  //   }\n  //   return views;\n  // }\n\n  // getViewStates(): {\n  //   [viewId: string]: Appearance;\n  // } {\n  //   const viewStates = {\n  //     [this.boardLayout.getViewId()]: this.boardLayout.cameraFrame,\n  //   };\n  //   const children = this.boardLayout.getVisibleNodes() || [];\n  //   for (const child of children) {\n  //     const nodeUri = child.nodeUri;\n  //     const layout = this.nodeViewLayouts[nodeUri];\n  //     if (layout && layout.hasView() && layout.viewIsActive(this.presenting)) {\n  //       const viewState = this.nodeViewLayouts[nodeUri]?.getViewState();\n  //       viewStates[nodeUri] = viewState;\n  //     }\n  //   }\n  //   return viewStates;\n  // }\n\n  // snapRotation(currentRotationOrbit: number): number {\n  //   if (currentRotationOrbit > 1 || currentRotationOrbit < -1) {\n  //     return currentRotationOrbit;\n  //   }\n  //   return Math.round(currentRotationOrbit);\n  // }\n\n  // setBoardCameraFrame(viewState: Appearance, viewId) {\n  //   if (this.presenting) {\n  //     // let the Canvas component increse timing from the zoom increments\n  //   } else {\n  //     this.boardLayout.cameraFrame = {\n  //       ...this.boardLayout.cameraFrame,\n  //       ...viewState,\n  //       rotationOrbit: this.snapRotation(viewState.rotationOrbit),\n  //     };\n  //   }\n  // }\n\n  // onViewStateChange({\n  //   viewState,\n  //   viewId,\n  //   interactionState,\n  //   oldViewState,\n  // }: ViewStateChangeParameters & { viewId: string }) {\n  //   // if board layout - change the main camera\n  //   if (viewId === this.boardLayout.getViewId()) {\n  //     this.setBoardCameraFrame(viewState, viewId);\n\n  //     // all children with views must be zoom synced or panned when board is panned\n  //     const children = this.boardLayout.getVisibleNodes() || [];\n  //     for (const child of children) {\n  //       this.updateNodeViewFromUserInteraction(child, viewState);\n  //       // if (\n  //       //   child.layoutKey === 'map' ||\n  //       //   child.layoutKey === 'timeline'\n  //       // ) {\n  //       //   const nodeUri = child.nodeUri;\n  //       //   const nodeLayout = this.nodeViewLayouts[nodeUri];\n  //       //   if (nodeLayout && nodeLayout.hasView()) {\n  //       //     const view = this.deck?.getViewports().find(v => v.id === viewId);\n  //       //     if (view) {\n  //       //       const nodePixels = this.getNodePixels(child, view);\n  //       //       const nodeCameraFrame = nodeLayout.getCameraFrame();\n  //       //       const zoomDiff = viewState.zoom - oldViewState.zoom;\n  //       //       // console.log('zoomDiff', zoomDiff);\n  //       //       nodeLayout.setCameraFrame(\n  //       //         {\n  //       //           ...nodeCameraFrame,\n  //       //           ...nodePixels,\n  //       //           zoom: nodeCameraFrame.zoom + zoomDiff,\n  //       //           // zoom:\n  //       //           //   (nodeLayout.parentNode.insight?.zoom || 0) + viewState.zoom, // nodeLayout.getCameraFrame().zoom + zoomDiff,\n  //       //         } as CameraKeyframe,\n  //       //         nodeUri\n  //       //       );\n  //       //     }\n  //       //   } else {\n  //       //     // console.log('no layout for', viewId);\n  //       //   }\n  //       // }\n  //     }\n\n  //     this.update();\n  //     this.updateSelectedNodeBox(this.selectedVersionUriCache);\n  //     this.emit('viewport:camerachange', viewState);\n  //   } else {\n  //     const nodeUri = viewId;\n  //     const nodeLayout = this.nodeViewLayouts[nodeUri];\n  //     if (nodeLayout) {\n  //       nodeLayout.setCameraFrame(viewState as any, nodeUri);\n  //       // const viewNode = this.boardLayout.getNodePropsFromNodeFrameUri(nodeUri);\n  //       this.update();\n  //       // update the camera on the node viewer to db\n  //       // do not do this here, instead when the view is inactivated\n  //       // this.emit('node:camerachange', {\n  //       //   viewState,\n  //       //   nodeProps: viewNode,\n  //       // });\n  //     } else {\n  //       // console.log('no layout for', viewId);\n  //     }\n  //   }\n  // }\n\n  // updateNodeViewFromUserInteraction(\n  //   nodeProps: NodeProps,\n  //   viewState: Appearance\n  // ) {\n  //   if (\n  //     nodeProps.layoutKey === 'map' ||\n  //     nodeProps.layoutKey === 'timeline' ||\n  //     nodeProps.layoutKey === 'gltf'\n  //   ) {\n  //     const nodeUri = Node.nodePropsToUri(nodeProps);\n  //     const viewId = this.boardLayout.getViewId();\n  //     const nodeLayout = this.nodeViewLayouts[nodeUri];\n  //     if (nodeLayout && nodeLayout.hasView()) {\n  //       const view = this.deck?.getViewports().find(v => v.id === viewId);\n  //       if (view) {\n  //         const nodePixels = this.getNodePixels(nodeProps, view);\n  //         // check if parent node has the animation from nodes = camera settings\n  //         const nodeCameraFrame =\n  //           this.boardLayout.getNodeFrame(nodeProps) ||\n  //           nodeLayout.getCameraFrame();\n  //         console.log('get node frame', nodeCameraFrame);\n  //         const pixelPadding = 0;\n  //         const viewX = nodePixels.viewX + pixelPadding;\n  //         const viewY = nodePixels.viewY + pixelPadding;\n  //         const width = nodePixels.width - pixelPadding * 2;\n  //         const height = nodePixels.height - pixelPadding * 2;\n  //         // const zoomDiff = viewState.zoom - oldViewState.zoom;\n  //         // console.log('zoomDiff', zoomDiff);\n  //         nodeLayout.setCameraFrame(\n  //           {\n  //             ...nodeCameraFrame,\n  //             viewX,\n  //             viewY,\n  //             width,\n  //             height,\n  //             // zoom: nodeCameraFrame.zoom + zoomDiff,\n  //             // zoom:\n  //             //   (nodeLayout.parentNode.insight?.zoom || 0) + viewState.zoom, // nodeLayout.getCameraFrame().zoom + zoomDiff,\n  //           } as Appearance,\n  //           nodeUri\n  //         );\n  //       }\n  //     } else {\n  //       // console.log('no layout for', viewId);\n  //     }\n  //   } else if (nodeProps.layoutKey === 'geo') {\n  //     const nodeUri = Node.nodePropsToUri(nodeProps);\n  //     const nodeLayout = this.nodeViewLayouts[nodeUri];\n  //     if (nodeLayout) {\n  //       // this is to sync the isTilted for the node viewer layers\n  //       // nodeLayout.setCameraFrame({ rotationX: viewState.rotationX });\n  //     }\n  //   }\n  // }\n\n  // // async canvasToArrayBuffer(\n  // //   canvas: HTMLCanvasElement,\n  // //   type: string,\n  // //   quality?: number\n  // // ) {\n  // //   const base64 = canvas.toDataURL(type, quality);\n  // //   const response = await fetch(base64);\n  // //   return await response.arrayBuffer();\n  // // }\n\n  // // async add(canvas: HTMLCanvasElement) {\n  // //   // Adding a frame just overwrites old image\n  // //   const buffer = await this.canvasToArrayBuffer(\n  // //     canvas,\n  // //     this.mimeType,\n  // //     this.quality\n  // //   );\n  // //   this.blob = new Blob([buffer], { type: this.mimeType });\n  // //   return Promise.resolve();\n  // // }\n\n  // deactivateViews() {\n  //   for (const nodeViewer of Object.values(this.nodeViewLayouts)) {\n  //     if (nodeViewer.viewIsActive(this.presenting)) {\n  //       console.log('deactivate and snapshot', nodeViewer.id);\n  //       this.snapshot(nodeViewer.id);\n  //       nodeViewer.setViewActive(false);\n  //       this.emit('view:deactivate', nodeViewer);\n  //     }\n  //   }\n  //   this.update();\n  // }\n\n  // activateView(nodeProps: NodeProps) {\n  //   const nodeUri = Node.nodePropsToUri(nodeProps);\n  //   console.log('activateView', nodeUri, nodeProps);\n  //   if (this.nodeViewLayouts[nodeUri]) {\n  //     const nodePixels = this.getNodePixels(nodeProps);\n  //     this.nodeViewLayouts[nodeUri].setCameraFrame({\n  //       // latitude: nodeProps.geometry?.coordinates[1], // figure out how to do with coordinate since geojson might be a polygon\n  //       ...nodePixels,\n  //       zoom: nodeProps.appearance?.zoom || 0,\n  //       rotationX: nodeProps.appearance?.rotationX || 0,\n  //       rotationOrbit: nodeProps.appearance?.rotationOrbit || 0,\n  //       longitude: nodeProps.appearance?.longitude,\n  //       latitude: nodeProps.appearance?.latitude,\n  //       bearing: nodeProps.appearance?.bearing || 0,\n  //       pitch: nodeProps.appearance?.pitch || 0,\n  //       target: nodeProps.appearance?.target || [0, 0, 0],\n  //     });\n  //     this.nodeViewLayouts[nodeUri].setViewActive(true);\n  //     this.emit('view:activate', this.nodeViewLayouts[nodeUri]);\n  //   } else {\n  //     console.warn('no node layout for', nodeUri);\n  //   }\n  //   this.update();\n  // }\n\n  // nodeViewerIsActive(nodeProps: NodeProps) {\n  //   return this.nodeViewLayouts[Node.nodePropsToUri(nodeProps)]?.viewIsActive(\n  //     this.presenting\n  //   );\n  // }\n\n  // emitSnapshot = debounce(nodeUri => {\n  //   this.snapshot(nodeUri);\n  //   this.update();\n  // }, 1000);\n\n  // snapshot(nodeUri?: string) {\n  //   // @ts-ignore\n  //   const ctx = this.canvas.getContext('webgl2');\n  //   let width;\n  //   let height;\n  //   let viewX;\n  //   let viewY;\n  //   let nodeProps;\n  //   let cameraView;\n\n  //   // snapshot on full board\n  //   if (!nodeUri || nodeUri === this.boardLayout.getViewId()) {\n  //     width = this.props.width;\n  //     height = this.props.height;\n  //     viewX = this.props.viewX || 0;\n  //     viewY = this.props.viewY || 0;\n\n  //     if (!width || !height) {\n  //       console.warn('no width or height');\n  //       return;\n  //     }\n\n  //     nodeProps = this.boardLayout.parentNodeProps;\n  //     cameraView = this.boardLayout.getCameraFrame();\n  //   } else {\n  //     // snapshot on node viewer\n  //     const nodeLayout = this.nodeViewLayouts[nodeUri];\n  //     if (nodeLayout) {\n  //       const view = true; // this.deck?.getViewports().find(v => v.id === nodeUri);\n  //       nodeProps = this.boardLayout.getNodePropsFromNodeFrameUri(nodeUri);\n  //       if (!view || !nodeProps) {\n  //         console.warn(\n  //           'no node frame for snapshot',\n  //           this.deck?.getViewports(),\n  //           nodeUri,\n  //           nodeProps\n  //         );\n  //         return;\n  //       }\n  //       const nodePixels = this.getNodePixels(\n  //         nodeProps\n  //         // view\n  //       );\n  //       width = nodePixels.width;\n  //       height = nodePixels.height;\n  //       viewX = nodePixels.viewX;\n  //       viewY = nodePixels.viewY;\n  //       cameraView = nodeLayout.getCameraFrame();\n  //     } else {\n  //       console.warn('no node layout for snapshot', nodeUri);\n  //       return;\n  //     }\n  //   }\n\n  //   // // Create a simple shader program\n  //   // const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);\n  //   // ctx.shaderSource(\n  //   //   vertexShader,\n  //   //   `\n  //   //   attribute vec2 a_position;\n  //   //   void main() {\n  //   //     gl_Position = vec4(a_position, 0, 1);\n  //   //   }\n  //   // `\n  //   // );\n  //   // ctx.compileShader(vertexShader);\n\n  //   // const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);\n  //   // ctx.shaderSource(\n  //   //   fragmentShader,\n  //   //   `\n  //   //   void main() {\n  //   //     gl_FragColor = vec4(1, 0, 0, 1);  // Red color\n  //   //   }\n  //   // `\n  //   // );\n  //   // ctx.compileShader(fragmentShader);\n\n  //   // const program = ctx.createProgram();\n  //   // ctx.attachShader(program, vertexShader);\n  //   // ctx.attachShader(program, fragmentShader);\n  //   // ctx.linkProgram(program);\n\n  //   // // Create a buffer for the rectangle's positions\n  //   // const positionBuffer = ctx.createBuffer();\n  //   // ctx.bindBuffer(ctx.ARRAY_BUFFER, positionBuffer);\n  //   // ctx.bufferData(\n  //   //   ctx.ARRAY_BUFFER,\n  //   //   new Float32Array([\n  //   //     -1,\n  //   //     -1, // First vertex\n  //   //     1,\n  //   //     -1, // Second vertex\n  //   //     -1,\n  //   //     1, // Third vertex\n  //   //     -1,\n  //   //     1, // Fourth vertex\n  //   //     1,\n  //   //     -1, // Fifth vertex\n  //   //     1,\n  //   //     1, // Sixth vertex\n  //   //   ]),\n  //   //   ctx.STATIC_DRAW\n  //   // );\n\n  //   // // Set the rectangle's positions for the vertex shader\n  //   // const positionLocation = ctx.getAttribLocation(program, 'a_position');\n  //   // ctx.enableVertexAttribArray(positionLocation);\n  //   // ctx.vertexAttribPointer(positionLocation, 2, ctx.FLOAT, false, 0, 0);\n\n  //   // // Draw the rectangle\n  //   // ctx.useProgram(program);\n  //   // ctx.drawArrays(ctx.TRIANGLES, 0, 6);\n\n  //   this.deck.redraw('true');\n\n  //   // Read the pixels\n  //   // const pixelsTest = new Uint8Array(width * height * 4);\n  //   // ctx.readPixels(\n  //   //   0,\n  //   //   0,\n  //   //   width,\n  //   //   height,\n  //   //   ctx.RGBA,\n  //   //   ctx.UNSIGNED_BYTE,\n  //   //   pixelsTest\n  //   // );\n\n  //   // // Check if the pixel data is as expected (red rectangle)\n  //   // const isPixelsAsExpected = pixelsTest.every((value, index) => {\n  //   //   // The pixel data is in RGBA format, so we check every 4th value for red, green, and blue\n  //   //   return (\n  //   //     (index % 4 === 0 && value === 255) || // Red\n  //   //     (index % 4 === 1 && value === 0) || // Green\n  //   //     (index % 4 === 2 && value === 0) || // Blue\n  //   //     (index % 4 === 3 && value === 255)\n  //   //   ); // Alpha\n  //   // });\n  //   // console.log(`Is pixel data as expected: ${isPixelsAsExpected}`);\n\n  //   // width = this.props.width;\n  //   // height = this.props.height;\n\n  //   ctx.finish();\n\n  //   // Create a buffer to store the pixel data\n  //   const pixels = new Uint8Array(width * height * 4);\n\n  //   // Unbind any currently bound framebuffer\n  //   // ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n\n  //   // Calculate the adjusted y-coordinate\n  //   const adjustedY = ctx.drawingBufferHeight - viewY - height;\n\n  //   // Read the pixels from the defined area\n  //   ctx.readPixels(\n  //     viewX,\n  //     adjustedY,\n  //     width,\n  //     height,\n  //     ctx.RGBA,\n  //     ctx.UNSIGNED_BYTE,\n  //     pixels\n  //   );\n\n  //   // // Fill the buffer with a pattern (alternating black and white pixels)\n  //   // // for (let i = 0; i < pixels.length; i += 4) {\n  //   // //   const color = (i / 4) % 2 === 0 ? 255 : 0; // Alternate between black and white\n  //   // //   pixels[i] = color; // Red\n  //   // //   pixels[i + 1] = color; // Green\n  //   // //   pixels[i + 2] = color; // Blue\n  //   // //   pixels[i + 3] = 255; // Alpha\n  //   // // }\n\n  //   // // Check if the pixel data is empty\n  //   // const isPixelsEmpty = pixels.every(value => value === 0);\n  //   // console.log(`Is pixel data empty: ${isPixelsEmpty}`);\n\n  //   // await this.add(this.canvas);\n\n  //   // Create a new canvas to draw the extracted part\n  //   const canvas = document.createElement('canvas');\n  //   canvas.width = width;\n  //   canvas.height = height;\n  //   const newCtx = canvas.getContext('2d');\n  //   const imageData = new ImageData(\n  //     new Uint8ClampedArray(pixels),\n  //     width,\n  //     height\n  //   );\n  //   newCtx.putImageData(imageData, 0, 0);\n\n  //   // Flip the image vertically\n  //   newCtx.save();\n  //   newCtx.scale(1, -1);\n  //   newCtx.drawImage(canvas, 0, 0, width, height, 0, -height, width, height);\n  //   newCtx.restore();\n\n  //   // Convert canvas to Blob\n  //   canvas.toBlob(blob => {\n  //     this.emit('snapshot', {\n  //       nodeProps,\n  //       cameraView,\n  //       blob, //: this.blob,\n  //     });\n  //   });\n\n  //   // else {\n  //   //   const nodeLayout = this.nodeViewLayouts[nodeUri];\n  //   //   if (nodeLayout) {\n  //   //     const view = this.deck?.getViewports().find(v => v.id === nodeUri);\n  //   //     const nodeProps =\n  //   //       this.boardLayout.getNodePropsFromNodeFrameUri(nodeUri);\n  //   //     if (!view || !nodeProps) {\n  //   //       console.warn(\n  //   //         'no node frame',\n  //   //         this.deck?.getViewports(),\n  //   //         nodeUri,\n  //   //         nodeProps\n  //   //       );\n  //   //       return;\n  //   //     }\n  //   //     const { viewX, viewY, width, height } = this.getNodePixels(\n  //   //       nodeProps\n  //   //       // view\n  //   //     );\n  //   //     // @ts-ignore\n  //   //     const ctx = this.deck.deckRenderer.gl;\n\n  //   //     console.log('snapshot', width, height, viewX, viewY);\n\n  //   //     if (!width || !height) {\n  //   //       console.warn('no width or height');\n  //   //       return;\n  //   //     }\n\n  //   //     // Create a buffer to store the pixel data\n  //   //     const pixels = new Uint8Array(width * height * 4);\n\n  //   //     // Read the pixels from the defined area\n  //   //     ctx.readPixels(\n  //   //       viewX,\n  //   //       viewY,\n  //   //       width,\n  //   //       height,\n  //   //       ctx.RGBA,\n  //   //       ctx.UNSIGNED_BYTE,\n  //   //       pixels\n  //   //     );\n\n  //   //     // Create a new canvas to draw the extracted part\n  //   //     const canvas = document.createElement('canvas');\n  //   //     canvas.width = width;\n  //   //     canvas.height = height;\n  //   //     const newCtx = canvas.getContext('2d');\n  //   //     const imageData = new ImageData(\n  //   //       new Uint8ClampedArray(pixels),\n  //   //       width,\n  //   //       height\n  //   //     );\n  //   //     newCtx.putImageData(imageData, 0, 0);\n\n  //   //     // Convert canvas to Blob\n  //   //     canvas.toBlob(blob => {\n  //   //       this.emit('snapshot', {\n  //   //         nodeProps,\n  //   //         blob,\n  //   //       });\n\n  //   //       // Upload the Blob to S3\n  //   //       // const params = {\n  //   //       //     Key: fileName,\n  //   //       //     Body: blob,\n  //   //       //     ContentType: 'image/png'\n  //   //       // };\n\n  //   //       // s3.upload(params, (err, data) => {\n  //   //       //     if (err) {\n  //   //       //         return console.error('Error uploading image:', err);\n  //   //       //     }\n  //   //       //     console.log('Successfully uploaded image to S3:', data.Location);\n  //   //       // });\n  //   //     }, 'image/png');\n\n  //   //     // Convert the new canvas to a Base64 string\n  //   //     // const dataURL = newCanvas.toDataURL('image/png');\n  //   //     // const base64String = dataURL.split(',')[1];\n\n  //   //     // // Create JSON structure\n  //   //     // const imageDataJson = {\n  //   //     //   image: base64String,\n  //   //     //   format: 'png',\n  //   //     //   metadata: {\n  //   //     //     width: width,\n  //   //     //     height: height,\n  //   //     //     extractedAt: new Date().toISOString(),\n  //   //     //   },\n  //   //     // };\n  //   //   }\n  //   // }\n  // }\n\n  // layerFilter({ layer, viewport }: FilterContext) {\n  //   if (!layer || !viewport) {\n  //     return false;\n  //   }\n  //   if (!layer.id.startsWith(viewport.id)) {\n  //     // console.log('skip layer', layer.id, viewport.id);\n  //     return false;\n  //   }\n  //   return true;\n  // }\n\n  // getLayers() {\n  //   const layers =\n  //     this.boardLayout.getLayers(\n  //       this.interactionManager,\n  //       null,\n  //       this.boardLayout.getViewId(),\n  //       this.presenting\n  //     ) || [];\n\n  //   // todo: check which children have an insight attached -> render child layers (or instantiate first if layout is not instantiated yet)\n  //   // ONLY FOR VISIBLE NODES of the active portal layout\n  //   const visibleNodes = this.boardLayout.getVisibleNodes() || [];\n  //   for (const child of visibleNodes) {\n  //     const { nodeUri } = child;\n  //     let nodeLayout = this.nodeViewLayouts[nodeUri];\n  //     // if the child viewer does NOT have a view - or if it HAS a view AND the view is active\n  //     if (\n  //       nodeLayout &&\n  //       (!nodeLayout.hasView() || nodeLayout.viewIsActive(this.presenting))\n  //     ) {\n  //       const childLayers = nodeLayout.getLayers(\n  //         this.interactionManager,\n  //         {\n  //           ...child,\n  //           appearance: {\n  //             ...child.appearance,\n  //             position: child.appearance.position,\n  //             size: child.appearance.size,\n  //           },\n  //         },\n  //         nodeLayout.hasView()\n  //           ? nodeLayout.getViewId()\n  //           : this.boardLayout.getViewId()\n  //       );\n  //       // console.log('childlayers', childLayers);\n  //       if (childLayers && childLayers.length > 0) {\n  //         layers.push(...childLayers);\n  //       }\n  //     }\n  //   }\n\n  //   return layers;\n  // }\n\n  // getNodeFrame(nodeProps: NodeProps) {\n  //   // todo: search node in nodeViewLayouts as well\n  //   return this.boardLayout.getNodeFrame(nodeProps);\n  // }\n\n  // async getFile(node, callback) {\n  //   // if (this.s3 && node._file?.key) {\n  //   //   this.s3.getObject(\n  //   //     {\n  //   //       Bucket: node._file.bucket,\n  //   //       Key: node._file.key,\n  //   //     },\n  //   //     (err, data) => {\n  //   //       if (err) {\n  //   //         callback(err);\n  //   //       } else {\n  //   //         callback(data.Body);\n  //   //       }\n  //   //     }\n  //   //   );\n  //   // }\n  // }\n\n  // getProps({ onNextFrame = undefined, extraProps = undefined } = {}) {\n  //   const backgroundColor =\n  //     this.boardLayout.getBackgroundColor() ||\n  //     this.props.backgroundColor ||\n  //     DEFAULT_BACKGROUND_COLOR;\n\n  //   const props: DeckProps = {\n  //     ...this.props,\n  //     ...extraProps,\n  //     _animate: false, //this.shouldAnimate,\n  //     parameters: {\n  //       // these are found in the mapbox overlay for the interleaved map\n  //       depthMask: true,\n  //       depthTest: true,\n  //       blend: true,\n  //       blendFunc: [\n  //         GL.SRC_ALPHA,\n  //         GL.ONE_MINUS_SRC_ALPHA,\n  //         GL.ONE,\n  //         GL.ONE_MINUS_SRC_ALPHA,\n  //       ],\n  //       polygonOffsetFill: true,\n  //       depthFunc: GL.LEQUAL,\n  //       blendEquation: GL.FUNC_ADD,\n  //       clearColor: [\n  //         backgroundColor[0] / 256,\n  //         backgroundColor[1] / 256,\n  //         backgroundColor[2] / 256,\n  //         1,\n  //       ],\n  //     },\n  //     width: this.props.width,\n  //     height: this.props.height,\n  //     viewState: this.getViewStates(),\n  //     views: this.getViews(),\n  //     onViewStateChange: this.onViewStateChange,\n  //     layerFilter: this.layerFilter,\n  //     getCursor: this.interactionManager.getCursor,\n  //     // onInteractionStateChange:\n  //     //   this.interactionManager.onInteractionStateChange,\n  //     // onDragStart: this.interaction.onDragStart,\n  //     // onDrag: this.interaction.onDrag,\n  //     // onDragEnd: this.interaction.onDragEnd,\n  //     layers: this.getLayers(),\n  //     effects: [],\n  //     getTooltip: null,\n  //   };\n\n  //   if (onNextFrame) {\n  //     props.onAfterRender = () => this.onAfterRender(onNextFrame);\n  //   } else {\n  //     props.onAfterRender = () => {\n  //       // const children = this.boardLayout.getVisibleNodes() || [];\n  //       // for (const child of children) {\n  //       //   this.updateNodeViewFromUserInteraction(child, {});\n  //       // }\n  //     };\n  //   }\n\n  //   return props;\n  // }\n\n  // getZoom() {\n  //   const viewState = this.boardLayout.getViewState();\n  //   return (viewState?.zoom || 0) as number;\n  // }\n\n  // getProjectNode() {\n  //   return this.projectNode;\n  // }\n\n  // // addNodeAtPixel(node: Node, pixel: number[]) {\n  // //   const coordinate = this.pixelToCartesian(pixel[0], pixel[1]);\n  // //   this.addNodeAtCoordinate(node, coordinate);\n  // // }\n\n  // // addNodeAtCoordinate(node: Node, coordinate: number[]) {\n  // //   if (this.boardLayout instanceof ManualLayout) {\n  // //     this.boardLayout.addNodeAtCoordinate(\n  // //       node,\n  // //       coordinate as [number, number]\n  // //     );\n  // //   }\n  // // }\n\n  // setInteractionMode(mode: InteractionMode) {\n  //   this.interactionMode = mode;\n  // }\n\n  // pixelToCartesian(x: number, y: number): number[] | null {\n  //   try {\n  //     const viewport = this.deck\n  //       ?.getViewports()\n  //       .find(v => v.id === this.boardLayout.getViewId());\n  //     if (!viewport) {\n  //       console.log('no viewport found', this.boardLayout.getViewId());\n  //       return null;\n  //     }\n  //     return viewport.unproject([x || 0, y || 0]);\n  //   } catch (e) {\n  //     console.log('error pixel to cartesian', e);\n  //     return null;\n  //   }\n  // }\n\n  // cartesianToPixel(x: number, y: number): number[] | null {\n  //   try {\n  //     const viewport = this.deck\n  //       ?.getViewports()\n  //       .find(v => v.id === this.boardLayout.getViewId());\n  //     if (!viewport) {\n  //       console.log('no viewport found', this.boardLayout.getViewId());\n  //       return null;\n  //     }\n  //     return viewport.project([x, y]);\n  //   } catch (e) {\n  //     return null;\n  //   }\n  // }\n\n  // update(updateTriggers?: UpdateTriggers) {\n  //   if (!this.deck) {\n  //     console.log('no deck');\n  //     return;\n  //   }\n  //   if (updateTriggers) {\n  //     this.boardLayout.applyUpdateTriggers(updateTriggers);\n  //   }\n  //   // console.log('update viewport');\n  //   try {\n  //     this.deck.setProps(this.getProps());\n  //   } catch (e) {\n  //     console.log('error updating viewport', e);\n  //   }\n  // }\n\n  // getNodePixels(\n  //   nodeProps: NodeProps,\n  //   boardViewport?: any\n  // ): {\n  //   viewX: number;\n  //   viewY: number;\n  //   width: number;\n  //   height: number;\n  // } {\n  //   let nodeFrame = this.boardLayout.getNodeFrame(nodeProps);\n  //   if (!nodeFrame) {\n  //     console.warn(\n  //       'no nodeFrame found in board layout - this is only for nodes within views - rare!?'\n  //     );\n  //     const nodeUri = Node.nodePropsToUri(nodeProps);\n  //     const nodeLayout = this.nodeViewLayouts[nodeUri];\n  //     if (nodeLayout) {\n  //       nodeFrame = nodeLayout.getNodeFrame(nodeProps);\n  //       if (!nodeFrame) {\n  //         console.warn(\n  //           'no nodeFrame found in nodeLayout in getNodePixels',\n  //           this,\n  //           nodeProps\n  //         );\n  //       }\n  //     } else {\n  //       console.warn('no nodeLayout found in getNodePixels', nodeUri);\n  //     }\n  //   }\n  //   if (!nodeFrame) {\n  //     console.warn('no nodeFrame found in getNodePixels', nodeProps);\n  //     const position = nodeProps.appearance?.position || [0, 0, 0];\n  //     const size = nodeProps.appearance?.size || [TILE_SIZE, TILE_SIZE];\n  //     nodeFrame = {\n  //       position,\n  //       size,\n  //     } as any;\n  //   }\n\n  //   const width = nodeFrame.size[0];\n  //   const height = nodeFrame.size[1];\n  //   const x = nodeFrame.position[0] - width / 2;\n  //   const y = nodeFrame.position[1] + height / 2;\n  //   const pixelTopLeft = boardViewport\n  //     ? boardViewport.project([x, y])\n  //     : this.cartesianToPixel(x, y);\n  //   const pixelBottomRight = boardViewport\n  //     ? boardViewport.project([x + width, y - height])\n  //     : this.cartesianToPixel(x + width, y - height);\n\n  //   if (!pixelTopLeft || !pixelBottomRight) {\n  //     console.log('no pixelTopLeft or pixelBottomRight', nodeProps);\n  //     return {\n  //       viewX: 0,\n  //       viewY: 0,\n  //       width: 10,\n  //       height: 10,\n  //     };\n  //   }\n\n  //   return {\n  //     viewX: Math.round(pixelTopLeft[0]),\n  //     viewY: Math.round(pixelTopLeft[1]),\n  //     width: Math.round(pixelBottomRight[0] - pixelTopLeft[0]),\n  //     height: Math.round(pixelBottomRight[1] - pixelTopLeft[1]),\n  //   };\n  // }\n\n  // // only for observedAt in nodes\n  // setTime(timing: number) {\n  //   // this.boardLayout.setTime(timing);\n  //   // for (const nodeLayout of Object.values(this.nodeViewLayouts)) {\n  //   //   nodeLayout.setTime(timing);\n  //   // }\n  //   // this.boardLayout.updatePolygons();\n  //   // this.boardLayout.setLastNodePositionUpdate();\n  //   // this.update();\n  // }\n\n  // setInsightCursor(timing: number | null) {\n  //   // this.timeline.setTime(timing);\n  //   this.boardLayout.setInsightCursor(timing >= 0 ? timing : null);\n  //   // for view Layouts\n  //   for (const nodeLayout of Object.values(this.nodeViewLayouts)) {\n  //     nodeLayout.setInsightCursor(timing);\n  //   }\n  //   this.interactionManager.createInitialConnectionHandles();\n  //   // this.boardLayout.updatePolygons();\n  //   this.boardLayout.setLastNodePositionUpdate();\n  //   this.update();\n  // }\n\n  // // getFrameOrder(nodeUri: string, timing: number) {\n  // //   console.log('is this called (viewport.getFrameOrder)?');\n  // //   if (this.boardLayout.nodeAnimations[nodeUri]) {\n  // //     return this.boardLayout.nodeAnimations[nodeUri].getFrameOrder(timing);\n  // //   } else {\n  // //     console.log('todo: try to find in child view layouts');\n  // //   }\n  // // }\n\n  // // RECORDING\n\n  // setAnimationProps() {\n  //   // this will loop the getProps and onNextFrame every ms of videoCapture\n  //   this.deck.setProps(this.getProps({ onNextFrame: this.setAnimationProps }));\n  // }\n\n  // record({\n  //   // Encoder = PreviewEncoder,\n  //   formatConfigs = {},\n  //   filename = undefined,\n  //   timecode = { start: 0, end: 0, framerate: 30 },\n  //   onStopped = undefined,\n  //   onSave = undefined,\n  //   onComplete = undefined,\n  // }) {\n  //   // todo: use the render function in deck-adapter\n  //   this.shouldAnimate = true;\n  //   // this.videoCapture.render({\n  //   //   Encoder,\n  //   //   formatConfigs,\n  //   //   timecode,\n  //   //   filename,\n  //   //   onStop: () => this.stop({onStopped, onSave, onComplete})\n  //   // });\n  //   // this.enabled = true;\n  //   this.seek({ timeMs: timecode.start });\n  //   // the update() call but with a the onNextFrame callback that will loop through the animation\n  //   this.deck.setProps(this.getProps({ onNextFrame: this.setAnimationProps }));\n  // }\n\n  // stopRecording({ onStopped, onSave, onComplete, abort }) {\n  //   // this.enabled = false; // todo: enableViewportInteraction\n  //   this.shouldAnimate = false;\n  //   this.videoCapture.stop({ onStopped, onSave, onComplete, abort });\n  // }\n\n  // // only use in recording from this.onAfterRender or this.record\n  // // otherwise set the time and\n  // seek({ timeMs }) {\n  //   if (timeMs || timeMs === 0) {\n  //     // this.boardLayout.timeline.setTime(timeMs);\n  //     // console.log('seek', timeMs);\n  //     // this.boardLayout.applyUpdateTriggers({\n  //     //   nodePositionChange: 1,\n  //     // });\n  //     // this.update();\n  //   }\n  //   // do some operation required during a draw call\n  //   // this.portalManager.draw();\n  // }\n\n  // // after each frame push the seek to the next time and run the callback = this.setAnimationProps\n  // onAfterRender(setAnimationProps, readyToCapture = true) {\n  //   const areAllLayersLoaded =\n  //     this.deck &&\n  //     this.deck.props.layers.every(layer => layer && (layer as Layer).isLoaded);\n  //   if (\n  //     this.videoCapture &&\n  //     this.videoCapture.isRecording() &&\n  //     areAllLayersLoaded &&\n  //     readyToCapture\n  //   ) {\n  //     this.videoCapture.capture(this.canvas, nextTimeMs => {\n  //       this.seek({ timeMs: nextTimeMs });\n  //       //\n  //       setAnimationProps(nextTimeMs);\n  //     });\n  //   }\n  // }\n\n  // downloadNodes = (\n  //   fileName: string,\n  //   nodeProps: NodeProps[],\n  //   fileType: 'json' | 'csv' = 'json',\n  //   keysToInclude?: string[]\n  // ) => {\n  //   const filter = keysToInclude || [];\n  //   const filterMap = filter.reduce((acc, key) => {\n  //     acc[key] = true;\n  //     return acc;\n  //   }, {});\n  //   const nodeData = nodeProps.map(n => {\n  //     const serialized = n;\n  //     const out = {};\n  //     for (const key of Object.keys(serialized)) {\n  //       if (filter.length && !filterMap[key]) {\n  //         continue;\n  //       }\n  //       out[key] = serialized[key];\n  //     }\n  //     return out;\n  //   });\n  //   let saveAs;\n  //   let stringData;\n\n  //   if (fileType === 'csv') {\n  //     const nodeDataSimplified = nodeData.map(n => {\n  //       const out = {};\n  //       for (const key of Object.keys(n)) {\n  //         // if is object - simplify it\n  //         if (typeof n[key] === 'object') {\n  //           if (n[key] instanceof Array && n[key].length > 0) {\n  //             // bucket properties can be arrays\n  //             if (n[key][0].type === 'Property') {\n  //               out[key] = n[key]\n  //                 .map(property => {\n  //                   return property.value;\n  //                 })\n  //                 .join(' ');\n  //             }\n  //             if (n[key][0].type === 'Relation') {\n  //               out[key] = n[key]\n  //                 .map(property => {\n  //                   return property.object;\n  //                 })\n  //                 .join(' ');\n  //             } else {\n  //               out[key] = n[key].join(' ');\n  //             }\n  //           } else if (n[key].type === 'Property') {\n  //             out[key] = n[key].value;\n  //           }\n  //         } else {\n  //           out[key] = n[key] || ' ';\n  //         }\n  //       }\n  //       return out;\n  //     });\n  //     saveAs = `${fileName}.csv`;\n  //     stringData = convertArrayOfObjectsToCSV(\n  //       nodeDataSimplified,\n  //       keysToInclude\n  //     );\n  //   } else {\n  //     saveAs = `${fileName}.json`;\n  //     stringData = JSON.stringify(nodeData);\n  //   }\n  //   let element = document.createElement('a');\n  //   element.setAttribute(\n  //     'href',\n  //     'data:text/plain;charset=utf-8,' + encodeURIComponent(stringData)\n  //   );\n  //   element.setAttribute('download', saveAs);\n  //   element.style.display = 'none';\n  //   document.body.appendChild(element);\n  //   element.click();\n  //   document.body.removeChild(element);\n  // };\n\n  // // hasModelMatrix(node: Node, insight: BucketInsight) {\n  // //   let values = [];\n  // //   const insightColumns = insight.sanddanceInsight?.columns;\n  // //   if (!insightColumns) {\n  // //     console.warn('no insight columns');\n  // //     return values;\n  // //   }\n  // //   if (node.isBucket()) {\n  // //     const dataSourceEdges = node.getInsightFromNodeEdges();\n  // //     const nodeMap: NodeMap = {};\n  // //     for (const edge of dataSourceEdges) {\n  // //       const dataSourceNode = edge.target;\n  // //       dataSourceNode.getCubeNodes(['volume'], nodeMap);\n  // //     }\n  // //     return Object.values(nodeMap).find(n => n._props.modelMatrix);\n  // //   }\n  // // }\n\n  // getNodeInteractionState(nodeUri: string) {\n  //   return this.interactionManager.nodeInteractionStates[nodeUri] || 'default';\n  // }\n\n  // setNodeInteractionState(nodeUri: string, state: NodeInteractionState) {\n  //   this.interactionManager.nodeInteractionStates[nodeUri] = state;\n  // }\n\n  // getEdgeInteractionState(edgeId: string) {\n  //   return this.interactionManager.edgeInteractionStates[edgeId] || 'default';\n  // }\n\n  // setEdgeInteractionState(edgeId: string, state: EdgeInteractionState) {\n  //   this.interactionManager.edgeInteractionStates[edgeId] = state;\n  // }\n\n  // // 3. The nodeProps can be sent in, as well as what should be triggered\n  // // applyNodeProps(nodeProps?: NodeProps[], updateTriggers?: UpdateTriggers) {\n  // //   console.log('IS THIS CALLED?');\n  // //   // update the cubes if parametricInput has changed -> do this separately instead\n  // //   // this.portal.applyNodeProps(nodeProps);\n\n  // //   // at this point the nodeProps has changed and should preplace state in the layout\n  // //   this.boardLayout.applyNodeProps(nodeProps);\n\n  // //   // trigger only if changed\n  // //   this.boardLayout.applyUpdateTriggers(updateTriggers);\n\n  // //   this.update();\n  // // }\n\n  // // GET DEFAULT NODE SIZE\n  // getDefaultNodeSize() {\n  //   return this.boardLayout.getDefaultNodeSize();\n  // }\n\n  // getFullTriggers() {\n  //   return {\n  //     nodePositionChange: Date.now(),\n  //     nodeSizeChange: Date.now(),\n  //     nodeExtrusionChange: Date.now(),\n  //     nodeScaleChange: Date.now(),\n  //     nodeRotateChange: Date.now(),\n  //     nodeFillColorChange: Date.now(),\n  //     nodeStrokeColorChange: Date.now(),\n  //   };\n  // }\n\n  // // UPDATE THE VISUAL NODES\n  // // setNodePropsMap({\n  // //   changedNodeProps,\n  // //   updateTriggers,\n  // // }: {\n  // //   changedNodeProps: NodeProps[];\n  // //   updateTriggers?: UpdateTriggers;\n  // // }) {\n  // //   this.applyNodeProps(changedNodeProps, updateTriggers);\n  // // }\n\n  // // initNodeProps(nodePropsList: NodeProps[], edgePropsList: EdgeProps[]) {\n  // //   // first: need to add parent groups for map and timeline\n  // //   const mapLayouts = new Map<string, NodeProps[]>();\n  // //   const timelineLayouts = new Map<string, NodeProps[]>();\n  // //   const boardLayoutNodes: NodeProps[] = [];\n  // //   for (const n of nodePropsList) {\n  // //     const nodeUri = Node.nodePropsToUri(n);\n  // //     if (n.layoutKey === 'map') {\n  // //       if (!mapLayouts.has(nodeUri)) {\n  // //         mapLayouts.set(nodeUri, []);\n  // //       }\n  // //     } else if (n.layoutKey === 'timeline') {\n  // //       if (!timelineLayouts.has(nodeUri)) {\n  // //         timelineLayouts.set(nodeUri, []);\n  // //       }\n  // //     }\n  // //   }\n\n  // //   // then: add nodeProps to the correct layout\n  // //   for (const n of nodePropsList) {\n  // //     if (mapLayouts[n.parentId]) {\n  // //       mapLayouts[n.parentId].push(n);\n  // //     } else if (timelineLayouts[n.parentId]) {\n  // //       timelineLayouts[n.parentId].push(n);\n  // //     } else {\n  // //       boardLayoutNodes.push(n);\n  // //     }\n  // //   }\n\n  // //   // init the board layout nodes\n  // //   // this.boardLayout.initNodeProps(boardLayoutNodes, []);\n\n  // //   // todo: create the map and timeline layouts\n  // // }\n\n  // updatePolygons() {\n  //   // this.boardLayout.updatePolygons();\n  //   this.boardLayout.setLastNodePositionUpdate();\n  //   this.update();\n  // }\n\n  // nodeHasSeparateLayoutParent(child: NodeProps, allNodes: NodePropsMap) {\n  //   const versionUri = `${child.parentId}/latest`;\n  //   const parent = allNodes.get(versionUri);\n  //   if (!parent) {\n  //     return false;\n  //   }\n  //   return Boolean(availableLayouts[parent.layoutKey]);\n  // }\n\n  // // some layouts must be ran before this step (grid, sankey, supplychain, map)\n  // // if the size change of a node with cubes/vega layout this needs to update after on receiver computer\n  // updateNodeProps({\n  //   nodes, // use for layout \"latest\" nodes\n  //   changedNodeProps,\n  //   updateTriggers, // Todo: use this to decide if rerender!\n  // }: {\n  //   nodes: NodePropsMap;\n  //   changedNodeProps: NodeProps[];\n  //   updateTriggers?: UpdateTriggers;\n  // }) {\n  //   // keep ref in viewport\n  //   this.nodes = nodes;\n\n  //   console.log('updateNodeProps', changedNodeProps, updateTriggers);\n\n  //   // todo: reduce function..\n  //   const childNodesWithSeparateLayout = new Map(\n  //     [...nodes].filter(([key, value]) =>\n  //       this.nodeHasSeparateLayoutParent(value, nodes)\n  //     )\n  //   );\n  //   const childNodesForBoardLayout = new Map(\n  //     [...nodes].filter(\n  //       ([key, value]) => !this.nodeHasSeparateLayoutParent(value, nodes)\n  //     )\n  //   );\n\n  //   // First: add the nodes without parentId to the boardLayout (this sets the overall layout nodes as containers to children)\n  //   const nodesWithoutParent = changedNodeProps.filter(n => !n.parentId);\n  //   if (nodesWithoutParent.length > 0) {\n  //     this.boardLayout.applyNodeProps(\n  //       childNodesForBoardLayout,\n  //       nodesWithoutParent\n  //     );\n  //   }\n\n  //   // Todo: do this as an optimization later\n  //   // delete all layouts if layout is changed\n  //   // for (const n of changedNodeProps) {\n  //   //   if (n.layoutKey) {\n  //   //     const nodeUri = Node.nodePropsToUri(n);\n  //   //     delete this.nodeViewLayouts[nodeUri];\n  //   //   }\n  //   // }\n\n  //   // Then: for the nodes with view, create nodeViewLayouts\n  //   const nodesWithView = changedNodeProps.filter(\n  //     n => n.layoutKey && n.layoutKey !== 'node'\n  //   );\n\n  //   // create all nodeViewers here (chart viewers are updated during updateChart later)\n  //   for (const n of nodesWithView) {\n  //     const nodeUri = Node.nodePropsToUri(n);\n  //     if (!this.nodeViewLayouts[nodeUri]) {\n  //       const originalNode = nodes.get(nodeUri);\n  //       const originalNodeWithChange = originalNode\n  //         ? mergeNodeProps([originalNode, n])[0]\n  //         : n;\n  //       this.createNodeViewer(originalNodeWithChange);\n  //     } else if (\n  //       this.nodeViewLayouts[nodeUri].parentNodeProps.layoutKey !== n.layoutKey\n  //     ) {\n  //       // recreate the nodeViewer with a different layout\n  //       const originalNode = nodes.get(nodeUri);\n  //       const originalNodeWithChange = originalNode\n  //         ? mergeNodeProps([originalNode, n])[0]\n  //         : n;\n  //       this.createNodeViewer(originalNodeWithChange);\n  //     }\n  //   }\n\n  //   // for nodes with parent - add them to either the boardLayout or the nodeViewLayouts\n  //   // todo: if node has parentId, find recusively the boardLayout.nodeId or the map or timeline nodeIds\n\n  //   const nodesWithParentOnBoardLayout = changedNodeProps.filter(\n  //     n => n.parentId && !this.nodeViewLayouts[n.parentId]\n  //   );\n  //   // these nodes have parent and no node viewer and should be added to the boardLayout\n  //   if (nodesWithParentOnBoardLayout.length > 0) {\n  //     this.boardLayout.applyNodeProps(\n  //       childNodesForBoardLayout,\n  //       nodesWithParentOnBoardLayout\n  //     );\n  //   }\n\n  //   const nodesWithNodeLayouts = changedNodeProps.filter(\n  //     n => n.parentId && this.nodeViewLayouts[n.parentId]\n  //   );\n  //   // these nodes have parent and node viewer and should be added to the respective nodeViewLayouts\n  //   for (const n of nodesWithNodeLayouts) {\n  //     const parentLayout = this.nodeViewLayouts[n.parentId];\n  //     const childNodesForNodeViewer = new Map(\n  //       [...childNodesWithSeparateLayout].filter(\n  //         ([key, value]) => value.parentId === n.parentId\n  //       )\n  //     );\n  //     parentLayout.applyNodeProps(childNodesForNodeViewer, [n]);\n  //   }\n\n  //   // update the viewers depending on parent changes or if layoutKey was changed\n  //   for (const n of changedNodeProps) {\n  //     const versionUri = Node.nodePropsToVersionUri(n);\n  //     const nodeId = Node.nodePropsToUri(n);\n\n  //     const parentLayout = this.nodeViewLayouts[nodeId];\n  //     if (parentLayout) {\n  //       const originalNode = nodes.get(versionUri);\n  //       if (!originalNode) {\n  //         console.log(\n  //           'original node not found',\n  //           originalNode,\n  //           versionUri,\n  //           n,\n  //           nodes\n  //         );\n  //         continue;\n  //       }\n\n  //       const layoutKey = n.layoutKey || originalNode.layoutKey;\n\n  //       // PARAMETRIC TO SEGMENTS !!!\n\n  //       // if parametric settings or properties has change - update cube cache\n  //       // NOTE: if several nodeProps changes and updateTriggers is set, all of the nodeProps will be updated\n  //       // however - normally only the nodeProps that has changed will be sent in (or all if init)\n  //       if (\n  //         layoutKey === 'cubes' ||\n  //         (layoutKey === 'vega' &&\n  //           (updateTriggers?.parametricChange ||\n  //             updateTriggers?.propertyChange))\n  //       ) {\n  //         let segments = getSegmentsFromNodeProps(originalNode);\n  //         if (layoutKey === 'cubes' && segments.length === 0) {\n  //           // ONLY FOR CUBES = if no explicit settings, represent the node itself as one cube = amount 1\n  //           segments = [\n  //             {\n  //               versionUri: Node.nodePropsToVersionUri(n),\n  //               amount: 1,\n  //               component: n.type,\n  //             } as ParametricCube,\n  //           ];\n  //         }\n  //         this.cubeCache.set(Node.nodePropsToVersionUri(n), segments);\n  //         console.log('set segments', segments);\n  //         parentLayout.applyNodeProps([], [originalNode], segments);\n  //       } else if (updateTriggers?.chartChange) {\n  //         let cachedSegments = this.cubeCache.get(versionUri);\n  //         if (cachedSegments) {\n  //           parentLayout.applyNodeProps([], [originalNode], cachedSegments);\n  //         }\n  //       } else {\n  //         // just change layout, not regenerate segment data\n  //         let cachedSegments = this.cubeCache.get(versionUri);\n  //         if (cachedSegments) {\n  //           parentLayout.applyNodeProps([], [originalNode], cachedSegments);\n  //         }\n  //       }\n  //     }\n  //   }\n\n  //   this.boardLayout.applyUpdateTriggers(updateTriggers);\n\n  //   if (Object.keys(updateTriggers || {}).length > 0) {\n  //     this.update();\n  //   }\n  // }\n\n  // getCubeCache(nodeProps: NodeProps) {}\n\n  // // make sure nodeProps is complete node, not only the change\n  // createNodeViewer(nodeProps: NodeProps) {\n  //   if (!availableLayouts[nodeProps.layoutKey]) {\n  //     console.warn('no layout for', nodeProps.layoutKey);\n  //     return;\n  //   }\n  //   const nodeUri = Node.nodePropsToUri(nodeProps);\n  //   const nodeViewer = new availableLayouts[nodeProps.layoutKey]({\n  //     parentNodeProps: nodeProps,\n  //     timeline: this.boardLayout.timeline,\n  //     // deck: this.deck,\n  //   } as LayoutProps);\n  //   if (nodeProps.layoutKey === 'map') {\n  //     const nodePixels = this.getNodePixels(nodeProps);\n  //     nodeViewer.setCameraFrame({\n  //       // latitude: nodeProps.geometry?.coordinates[1], // figure out how to do with coordinate since geojson might be a polygon\n  //       ...nodePixels,\n  //       // ...nodeProps.appearance,\n  //       minZoom: nodeProps.appearance?.minZoom || 0,\n  //       maxZoom: nodeProps.appearance?.maxZoom || 20,\n  //       zoom: nodeProps.appearance?.zoom || 0,\n  //       longitude: nodeProps.appearance?.longitude || 0.1,\n  //       latitude: nodeProps.appearance?.latitude || 0.1,\n  //       bearing: nodeProps.appearance?.bearing || 0,\n  //       pitch: nodeProps.appearance?.pitch || 0,\n  //     });\n  //   } else if (nodeProps.layoutKey === 'gltf') {\n  //     console.log('start gltf', nodeProps);\n  //     const nodePixels = this.getNodePixels(nodeProps);\n  //     nodeViewer.setCameraFrame({\n  //       // latitude: nodeProps.geometry?.coordinates[1], // figure out how to do with coordinate since geojson might be a polygon\n  //       ...nodePixels,\n  //       // ...n.appearance,\n  //       minZoom: nodeProps.appearance?.minZoom || -10,\n  //       maxZoom: nodeProps.appearance?.maxZoom || 20,\n  //       zoom: nodeProps.appearance?.zoom || 0,\n  //       rotationX: nodeProps.appearance?.rotationX || 0,\n  //       rotationOrbit: nodeProps.appearance?.rotationOrbit || 0,\n  //       target: nodeProps.appearance?.target || [0, 0, 0],\n  //     });\n  //   }\n  //   this.nodeViewLayouts[nodeUri] = nodeViewer;\n  // }\n\n  // // this is only for the children in boardLayout (sankey, supply chain, grid, etc)\n  // // difference between this kind of layout and parametric charts is that the appearance\n  // // goes back into db - so users can adjust position and size after layouted\n  // // the parametric charts are 100% generated on the client side (on the fly)\n  // // updateNodeLayouts({\n  // //   parentNodeProps,\n  // //   allNodeProps,\n  // // }: {\n  // //   parentNodeProps: NodeProps;\n  // //   allNodeProps: NodePropsMap;\n  // // }) {\n  // //   const childPropsMap: NodePropsMap = new Map();\n  // //   const children = getChildNodes(\n  // //     allNodeProps,\n  // //     Node.nodePropsToUri(parentNodeProps)\n  // //   );\n  // //   getSupplyChainLayout(parentNodeProps, children);\n  // // }\n\n  // // the nodeProps.parametric has changed and the cubes are unique per versionUri\n  // // so they are cached and used in layout run\n  // // obviously this must be done before updateCharts\n  // // updateParametric({ changedNodeProps }: { changedNodeProps: NodeProps[] }) {\n  // //   for (const nodeProps of changedNodeProps) {\n  // //     // if (\n  // //     //   (nodeProps.parametric && nodeProps.layoutKey === 'cubes') ||\n  // //     //   nodeProps.layoutKey === 'vega'\n  // //     // ) {\n  // //     const cubes = getCubesFromNodeProps(nodeProps);\n  // //     this.cubeCache.set(Node.nodePropsToVersionUri(nodeProps), cubes);\n  // //     // } else if (nodeProps.properties) {\n  // //     //   const cubes = getCubesFromNodeProps(nodeProps);\n  // //     //   this.cubeCache.set(Node.nodePropsToVersionUri(nodeProps), cubes);\n  // //     // }\n  // //   }\n  // // }\n\n  // // must be updated if chart type / settings or size has changed\n  // // explain why we need to keep instances of the chart layout? -> the cubes are cached on this.cubeCache\n  // // so why not do one-shot like supply-chain etc\n  // // updateCharts({\n  // //   changedNodeProps,\n  // //   allNodeProps, // for deriving data source\n  // // }: {\n  // //   changedNodeProps: NodeProps[];\n  // //   allNodeProps: NodePropsMap;\n  // // }) {\n  // //   for (const node of changedNodeProps) {\n  // //     if (node.layoutKey !== 'cubes' && node.layoutKey !== 'vega') {\n  // //       continue;\n  // //     }\n  // //     const nodeUri = Node.nodePropsToUri(node);\n  // //     const versionUri = Node.nodePropsToVersionUri(node);\n\n  // //     let nodeLayout = this.nodeViewLayouts[nodeUri];\n  // //     if (!nodeLayout && availableLayouts[node.layoutKey]) {\n  // //       nodeLayout = new availableLayouts[node.layoutKey]({\n  // //         parentNodeProps: node,\n  // //         timeline: this.boardLayout.timeline,\n  // //       } as LayoutProps);\n  // //       let cachedSegments = this.cubeCache.get(versionUri);\n  // //       if (!cachedSegments) {\n  // //         this.updateParametric({ changedNodeProps: [node] });\n  // //         cachedSegments = this.cubeCache.get(versionUri);\n  // //       }\n  // //       if (cachedSegments) {\n  // //         console.log(\n  // //           'node viewer was created from chart!',\n  // //           nodeUri,\n  // //           cachedSegments\n  // //         );\n  // //         nodeLayout.applyNodeProps([], [node], cachedSegments);\n  // //         this.nodeViewLayouts[nodeUri] = nodeLayout;\n  // //       }\n  // //     } else if (nodeLayout) {\n  // //       let cachedSegments = this.cubeCache.get(versionUri);\n  // //       if (!cachedSegments) {\n  // //         this.updateParametric({ changedNodeProps: [node] });\n  // //         cachedSegments = this.cubeCache.get(versionUri);\n  // //       }\n  // //       if (cachedSegments) {\n  // //         nodeLayout.applyNodeProps([], [node], cachedSegments);\n  // //       }\n  // //     } else {\n  // //       console.log('no layout for', nodeUri);\n  // //     }\n  // //     // if (node.layoutKey === 'cubes') {\n  // //     //   let cubesLayout = this.nodeViewLayouts[nodeUri];\n  // //     //   if (!cubesLayout) {\n  // //     //     const nodeLayout = new availableLayouts[nodeLayoutKey]({\n  // //     //       nodeProps,\n  // //     //       timeline: this.boardLayout.timeline,\n  // //     //       viewportProps: this.props,\n  // //     //     } as LayoutProps);\n  // //     //     this.createNodeLayout(node, 'cubes');\n  // //     //   }\n  // //     // }\n  // //   }\n  // // }\n\n  // // cubes need to be cached per insight when insight settings are changed\n  // // NOTE: these cubes are not the same as the cubes in animation! these are precalculated cube data that goes into layout run\n  // // updateCubeCache(nodeProps: NodeProps) {\n  // //   const cubes = getCubesFromNodeProps(nodeProps);\n  // //   // todo: for each cube, push into nodeFrame on nodeProps.versionUri + cube.ordinal\n  // //   this.cubeCache.set(Node.nodePropsToVersionUri(nodeProps), cubes);\n  // //   // console.log(\n  // //   //   'added to cube cache',\n  // //   //   Node.nodePropsToVersionUri(nodeProps),\n  // //   //   cubes\n  // //   // );\n  // // }\n\n  // updateEdgeProps({ changedEdgeProps }) {\n  //   // update the layout\n  //   this.boardLayout.applyEdgeProps(changedEdgeProps);\n  //   // update the layers\n  //   this.update();\n  // }\n\n  // // setViewActive(nodeProps: NodeProps, setActive: boolean) {\n  // //   const nodeUri = Node.nodePropsToUri(nodeProps);\n  // //   if (this.nodeViewLayouts[nodeUri]) {\n  // //     const nodePixels = this.getNodePixels(nodeProps);\n  // //     // this.nodeViewLayouts[nodeUri].setCameraFrame({\n  // //     //   // latitude: nodeProps.geometry?.coordinates[1], // figure out how to do with coordinate since geojson might be a polygon\n  // //     //   ...nodePixels,\n  // //     //   zoom: nodeProps.appearance?.zoom || 0,\n  // //     //   longitude: nodeProps.appearance?.longitude,\n  // //     //   latitude: nodeProps.appearance?.latitude,\n  // //     //   bearing: nodeProps.appearance?.bearing || 0,\n  // //     //   pitch: nodeProps.appearance?.pitch || 0,\n  // //     // });\n  // //     // now the view will be rendered\n  // //     this.nodeViewLayouts[nodeUri].setViewActive(setActive);\n  // //   }\n  // // }\n\n  // // MY OWN SELECTION\n  // updateMySelection(versionUris: string[]) {\n  //   const nodeUriToColors: Record<string, [number, number, number]> =\n  //     versionUris.reduce((acc, nodeUri, i) => {\n  //       acc[nodeUri] = [0, 0, 0];\n  //       return acc;\n  //     }, {});\n  //   console.log('update selection', nodeUriToColors);\n  //   this.interactionManager.setNodeSelectionColors(nodeUriToColors);\n  //   this.boardLayout.setLastNodeStyleUpdate();\n  //   // for (const versionUri of versionUris) {\n  //   //   const nodeUri = Node.versionUriToNodeUri(versionUri);\n  //   //   if (\n  //   //     this.nodeViewLayouts[nodeUri] &&\n  //   //     this.nodeViewLayouts[nodeUri].viewIsActive(this.presenting)\n  //   //   ) {\n  //   //     this.nodeViewLayouts[nodeUri].setViewActive(false);\n  //   //   }\n  //   // }\n  //   // set the selection on active layout\n\n  //   // this.boardLayout.setSelection(versionUris);\n  //   // // trigger update in rendered layers\n  //   // this.boardLayout.updateMySelectionStrokeColors(versionUris);\n  //   // // update the selected nodes box layer\n  //   this.updateSelectedNodeBox(versionUris);\n  //   // // trigger update in resize handles (uses layout.selectedVersionUris[0] to create handles)\n  //   // this.boardLayout.setLastResizeHandlePositionUpdate();\n  //   this.update();\n  // }\n\n  // updateMyEdgeSelection(edgeIds: string[]) {\n  //   const edgeIdToColors: Record<string, [number, number, number]> =\n  //     edgeIds.reduce((acc, edgeId, i) => {\n  //       acc[edgeId] = [0, 0, 0];\n  //       return acc;\n  //     }, {});\n  //   this.interactionManager.setEdgeSelectionColors(edgeIdToColors);\n  //   this.boardLayout.updateTriggers.edgeFillColorChange = Date.now();\n  //   this.update();\n  // }\n\n  // // SELECTION BOX AROUND THE SELECTED NODES\n  // updateSelectedNodeBox(versionUris: string[]) {\n  //   // this is needed to rerender the selection extent from the viewport\n  //   this.selectedVersionUriCache = versionUris;\n\n  //   // const coordinateExtent =\n  //   //   this.boardLayout.updateSelectedNodesBox(\n  //   //     versionUris && versionUris.length > 1 ? versionUris : []\n  //   //   ) || null;\n  //   const coordinateExtent =\n  //     this.boardLayout.updateSelectedNodesBox(versionUris) || null;\n  //   if (coordinateExtent) {\n  //     const min = this.cartesianToPixel(\n  //       coordinateExtent[0],\n  //       coordinateExtent[1]\n  //     );\n  //     const max = this.cartesianToPixel(\n  //       coordinateExtent[2],\n  //       coordinateExtent[3]\n  //     );\n\n  //     if (min && max) {\n  //       const pixelExtent = [...min, ...max];\n  //       this.emit('viewport:selectionextent', { pixelExtent });\n  //       return;\n  //     }\n  //   }\n  //   this.emit('viewport:selectionextent', { pixelExtent: null });\n  // }\n\n  // setResizeNode(nodeProps: NodeProps | null) {\n  //   this.interactionManager.setResizeNode(nodeProps);\n  //   this.update();\n  // }\n\n  // setConnectionNode(nodeProps: NodeProps | null) {\n  //   this.interactionManager.setConnectionNode(nodeProps);\n  //   this.update();\n  // }\n\n  // // SELECTION COLORS OF THE USERS\n  // setSelectionColors(\n  //   nodeUriToColors: Record<string, [number, number, number]>\n  // ) {\n  //   this.interactionManager.setNodeSelectionColors(nodeUriToColors);\n  // }\n\n  // // todo: this is duplicated\n  // createEdgeId(sourceUri: string, relationKey: string, targetUri: string) {\n  //   return getEdgeId({ sourceUri, relationKey, targetUri });\n  // }\n\n  // // used to pick only the board layout nodes and edges (context menu)\n  // pickBoardLayout(pixel: Pixel, dim3: boolean = false): any | null {\n  //   try {\n  //     const [x, y] = pixel;\n  //     const pickInfo = this.deck.pickObject({\n  //       x,\n  //       y,\n  //       // radius: 30,\n  //       layerIds: [\n  //         this.boardLayout.getLayerId('node-icon-layer'),\n  //         this.boardLayout.getLayerId(NODE_POLYGON_LAYER_KEY),\n  //         this.boardLayout.getLayerId(EDGE_NODE_LAYER_KEY),\n  //         this.boardLayout.getLayerId(BEZIER_EDGE_LABEL_LAYER_ID),\n  //         this.boardLayout.getLayerId(STRAIGHT_EDGE_LABEL_LAYER_ID),\n  //         this.boardLayout.getLayerId('edge-bezier-layer'),\n  //         this.boardLayout.getLayerId('edge-line-layer'),\n  //       ],\n  //       unproject3D: dim3,\n  //     });\n  //     return pickInfo?.object || null;\n  //   } catch (e) {\n  //     return null;\n  //   }\n  // }\n\n  // // PICKING ITEM ON THE CANVAS\n  // pick(pixel: Pixel, dim3: boolean = false): any | null {\n  //   try {\n  //     const [x, y] = pixel;\n\n  //     // the active node viewer layers dont need to be picked as they have it's own view that is interactive\n  //     // only the node image is picked on top\n  //     // const activeNodeViewerLayerIds = Object.values(this.nodeViewLayouts).map(\n  //     //   nodeLayout => nodeLayout.getLayerId('context-grid-layer-0')\n  //     // );\n  //     // console.log('activeNodeViewerLayerIds', activeNodeViewerLayerIds);\n  //     // todo: create priority for picking different layers and return what is picked\n  //     // handles, text, image, node, edge\n  //     const pickInfo = this.deck.pickObject({\n  //       x,\n  //       y,\n  //       // radius: 30,\n  //       // layerIds: [\n  //       //   this.boardLayout.getLayerId(RESIZE_HANDLE_LAYER_KEY),\n  //       //   this.boardLayout.getLayerId(CONNECTION_HANDLE_LAYER_KEY),\n  //       //   this.boardLayout.getLayerId('node-icon-layer'),\n  //       //   this.boardLayout.getLayerId(NODE_POLYGON_LAYER_KEY),\n  //       //   this.boardLayout.getLayerId(EDGE_NODE_LAYER_KEY),\n  //       //   this.boardLayout.getLayerId(BEZIER_EDGE_LABEL_LAYER_ID),\n  //       //   this.boardLayout.getLayerId(STRAIGHT_EDGE_LABEL_LAYER_ID),\n  //       //   this.boardLayout.getLayerId('edge-bezier-layer'),\n  //       //   this.boardLayout.getLayerId('edge-line-layer'),\n  //       //   this.boardLayout.getLayerId(\n  //       //     `${this.boardLayout.getViewId()}-vega-cubes`\n  //       //   ),\n  //       // ...activeNodeViewerLayerIds,\n  //       // ],\n  //       unproject3D: dim3,\n  //     });\n\n  //     // const cubeLayerId = this.portal.getLayerId(`${this.portal.node.id}-vega-cubes`)\n  //     return pickInfo?.object || null;\n  //   } catch (e) {\n  //     return null;\n  //   }\n  // }\n\n  // // SET RESIZE FOR SELECTED NODE\n  // setResizeHandles(versionUris: string[]) {\n  //   // this.boardLayout.setResizeHandles(\n  //   //   versionUris.length > 0 ? versionUris[0] : undefined\n  //   // );\n  // }\n\n  // // setNodeName(versionUri: string, name: string) {\n  // //   this.boardLayout.setNodeName(versionUri, name);\n  // // }\n\n  // setNodeType(versionUri: string, type: string) {\n  //   // this.boardLayout.setNodeType(versionUri, type);\n  // }\n\n  // runAutoLayout(\n  //   nodeProps: NodeProps,\n  //   overrideChildren?: NodeProps[]\n  // ): NodeProps[] {\n  //   // take all children recursively of the nodeProps node and apply layout\n  //   // input into layout -> nodes, output -> nodes with appearance changed\n  //   // add the result to the layout at that timing -> applyNodeProps\n  //   return [];\n  //   // const supplyChainLayout = new SupplyChainLayout({\n  //   //   nodeProps,\n  //   //   timeline: this.boardLayout.timeline,\n  //   // });\n  //   // const versionUri = Node.nodePropsToVersionUri(nodeProps);\n  //   // const children =\n  //   //   overrideChildren || this.boardLayout.getChildNodes(versionUri);\n  //   // supplyChainLayout.applyNodeProps([nodeProps, ...children]);\n  //   // supplyChainLayout.run(nodeProps);\n  //   // const updatedNodeProps = [nodeProps, ...children].map(child => {\n  //   //   const frame = supplyChainLayout.getNodeFrame(child);\n  //   //   if (\n  //   //     !frame ||\n  //   //     !frame.position ||\n  //   //     !frame.position[0] ||\n  //   //     !frame.position[1]\n  //   //   ) {\n  //   //     console.log('no position - add one', child);\n  //   //     return child;\n  //   //   }\n  //   //   child.appearance.position = frame.position;\n  //   //   return child;\n  //   // });\n  //   // // do not apply nodeProps to layout, instead return the updated nodeProps and update for all users - including the user that triggered the layout\n  //   // // if (!overrideChildren) {\n  //   // //   this.boardLayout.applyNodeProps(updatedNodeProps);\n  //   // //   this.update();\n  //   // // }\n  //   // return updatedNodeProps;\n  //   // this.boardLayout.runAutoLayout(nodeProps, layoutKey);\n  // }\n\n  // updateNodesFromNodeProps(changes: NodeProps[]) {\n  //   for (const change of changes) {\n  //     const node = change.synthetic\n  //       ? new SyntheticNode(change)\n  //       : new Node(change);\n  //     this.projectNode.addNode(node);\n  //   }\n  // }\n}\n"],"mappings":"wKACA,OAEE,qBAAAA,MAGK,sBA6LA,IAAMC,EAAe,CAC1B,GAAI,SACJ,KAAM,QACN,OAAQ,EACR,cAAe,IACf,mBAAoB,EACpB,iBAAkB,QACpB,EAEaC,EAA0C,CAErD,YAAa,CACX,IAAK,UACL,KAAM,CAAE,KAAM,SAAU,EACxB,KAAM,UACN,UAAWF,EACX,WAAYC,CACd,EACA,SAAU,CAAC,CACb,EC7MA,SAASE,EACPC,EACAC,EACAC,EACA,CACAA,EAASF,CAAI,EAAIE,EAASF,CAAI,GAAK,CAAC,EAChCE,EAASF,CAAI,EAAE,QAAQC,CAAQ,EAAI,GAErCC,EAASF,CAAI,EAAE,KAAKC,CAAQ,CAEhC,CAEA,SAASE,EACPH,EACAC,EACAC,EACA,CACA,GAAIA,EAASF,CAAI,EAAG,CAClB,IAAMI,EAAQF,EAASF,CAAI,EAAE,QAAQC,CAAQ,EACzCG,GAAS,GACXF,EAASF,CAAI,EAAE,OAAOI,EAAO,CAAC,EAGpC,CAKA,IAAqBC,EAArB,KAAiC,CAAjC,cACEC,EAAA,kBAA+B,CAAC,GAChCA,EAAA,sBAAmC,CAAC,GAKpC,GAAGN,EAAcC,EAAoB,CACnCF,EAAiBC,EAAMC,EAAU,KAAK,UAAU,CAClD,CAKA,KAAKD,EAAcC,EAAoB,CACrCF,EAAiBC,EAAMC,EAAU,KAAK,cAAc,CACtD,CAKA,IAAID,EAAcC,EAAoB,CACpCE,EAAoBH,EAAMC,EAAU,KAAK,UAAU,EACnDE,EAAoBH,EAAMC,EAAU,KAAK,cAAc,CACzD,CAEA,KAAKM,EAA6BC,EAAY,CA/DhD,IAAAC,EAAAC,EAgEI,IAAIC,EACA,OAAOJ,GAAgB,SACzBI,EAAQ,CAAE,KAAMJ,CAAY,EAE5BI,EAAQJ,EAGV,IAAMP,EAAOW,EAAM,KAEnB,GAAI,CAAC,KAAK,SAASX,CAAI,EACrB,OAGEQ,IACFG,EAAM,KAAOH,GAIf,IAAMI,IAAYH,EAAA,KAAK,WAAWT,CAAI,IAApB,YAAAS,EAAuB,UAAW,CAAC,EAErD,QAAWR,KAAYW,EACrBX,EAAS,KAAK,KAAMU,CAAK,EAG3B,IAAME,IAAgBH,EAAA,KAAK,eAAeV,CAAI,IAAxB,YAAAU,EAA2B,UAAW,CAAC,EAC7D,QAAWT,KAAYY,EACrBV,EAAoBH,EAAMC,EAAU,KAAK,cAAc,EACvDA,EAAS,KAAK,KAAMU,CAAK,CAE7B,CAKQ,SAASX,EAAuB,CACtC,OACG,KAAK,WAAWA,CAAI,GAAK,KAAK,WAAWA,CAAI,EAAE,OAAS,GACxD,KAAK,eAAeA,CAAI,GAAK,KAAK,eAAeA,CAAI,EAAE,OAAS,CAErE,CACF,ECxGA,OAAe,QAAAc,OAAoC,sBCWnD,OAGE,QAAAC,EAqBA,kBAAAC,EAGA,aAAAC,OAIK,sBDvCP,OAAmC,aAAAC,OAAiB,sBEFpD,OACE,mBAAAC,OAEK,6BC2EP,IAAMC,EAAQ,GAeP,IAAMC,EAAN,cAAyBC,CAAY,CA+B1C,YAAYC,EAAgC,CAC1C,MAAM,EA/BRC,EAAA,cACAA,EAAA,aACAA,EAAA,eAEAA,EAAA,uBAEI,CAAC,GAGLA,EAAA,aAAsB,IAAI,KAE1BA,EAAA,oBAEAA,EAAA,iBACAA,EAAA,2BACAA,EAAA,uBAAmC,WACnCA,EAAA,qBAAyB,IACzBA,EAAA,qBACAA,EAAA,kBAAsB,IAGtBA,EAAA,iBAA2C,IAAI,KAG/CA,EAAA,+BAAoC,CAAC,GAErCA,EAAA,aACAA,EAAA,gBAAmB,aACnBA,EAAA,eAAkB,GAKhB,GAAM,CAAE,gBAAAC,EAAiB,MAAAC,EAAO,YAAAC,EAAa,WAAAC,EAAY,GAAGC,CAAU,EACpEN,EACI,CAAE,YAAaO,EAAoB,GAAGC,CAA2B,EACrEC,EACIC,EAAgB,OAAO,OAC3B,CAEE,MAAO,OAAO,WACd,OAAQ,OAAO,WACjB,EACAF,EACAF,EAEA,CAEE,QAAUK,GAAiB,CACrBX,EAAc,eAChBA,EAAc,cAAcW,CAAK,CAErC,EAIA,WAAY,KAEZ,MAAOC,GAAST,GAAS,EAC3B,CACF,CAsEF,CA8vDF","names":["DEFAULT_NAMESPACE","defaultState","defaultNodeViewerProps","addEventListener","type","listener","registry","removeEventListener","index","EventSource","__publicField","eventOrType","data","_a","_b","event","listeners","onceListeners","Node","Node","NODE_TYPE_TYPE","getEdgeId","OrbitView","ScenegraphLayer","DEBUG","NodeViewer","EventSource","viewportProps","__publicField","interactionMode","debug","projectNode","presenting","restProps","defaultProjectNode","restDefaultNodeViewerProps","defaultNodeViewerProps","resolvedProps","error","DEBUG"]}